// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app/router/command/command.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// RoutingContext is the context with information relative to routing process.
/// It conforms to the structure of xray.features.routing.Context and
/// xray.features.routing.Route.
public struct Xray_App_Router_Command_RoutingContext: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inboundTag: String = String()

  public var network: Xray_Common_Net_Network = .unknown

  public var sourceIps: [Data] = []

  public var targetIps: [Data] = []

  public var sourcePort: UInt32 = 0

  public var targetPort: UInt32 = 0

  public var targetDomain: String = String()

  public var `protocol`: String = String()

  public var user: String = String()

  public var attributes: Dictionary<String,String> = [:]

  public var outboundGroupTags: [String] = []

  public var outboundTag: String = String()

  public var localIps: [Data] = []

  public var localPort: UInt32 = 0

  public var vlessRoute: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SubscribeRoutingStatsRequest subscribes to routing statistics channel if
/// opened by xray-core.
/// * FieldSelectors selects a subset of fields in routing statistics to return.
/// Valid selectors:
///  - inbound: Selects connection's inbound tag.
///  - network: Selects connection's network.
///  - ip: Equivalent as "ip_source" and "ip_target", selects both source and
///  target IP.
///  - port: Equivalent as "port_source" and "port_target", selects both source
///  and target port.
///  - domain: Selects target domain.
///  - protocol: Select connection's protocol.
///  - user: Select connection's inbound user email.
///  - attributes: Select connection's additional attributes.
///  - outbound: Equivalent as "outbound" and "outbound_group", select both
///  outbound tag and outbound group tags.
/// * If FieldSelectors is left empty, all fields will be returned.
public struct Xray_App_Router_Command_SubscribeRoutingStatsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fieldSelectors: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TestRouteRequest manually tests a routing result according to the routing
/// context message.
/// * RoutingContext is the routing message without outbound information.
/// * FieldSelectors selects the fields to return in the routing result. All
/// fields are returned if left empty.
/// * PublishResult broadcasts the routing result to routing statistics channel
/// if set true.
public struct Xray_App_Router_Command_TestRouteRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routingContext: Xray_App_Router_Command_RoutingContext {
    get {return _storage._routingContext ?? Xray_App_Router_Command_RoutingContext()}
    set {_uniqueStorage()._routingContext = newValue}
  }
  /// Returns true if `routingContext` has been explicitly set.
  public var hasRoutingContext: Bool {return _storage._routingContext != nil}
  /// Clears the value of `routingContext`. Subsequent reads from it will return its default value.
  public mutating func clearRoutingContext() {_uniqueStorage()._routingContext = nil}

  public var fieldSelectors: [String] {
    get {return _storage._fieldSelectors}
    set {_uniqueStorage()._fieldSelectors = newValue}
  }

  public var publishResult: Bool {
    get {return _storage._publishResult}
    set {_uniqueStorage()._publishResult = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Xray_App_Router_Command_PrincipleTargetInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_OverrideInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_BalancerMsg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var override: Xray_App_Router_Command_OverrideInfo {
    get {return _override ?? Xray_App_Router_Command_OverrideInfo()}
    set {_override = newValue}
  }
  /// Returns true if `override` has been explicitly set.
  public var hasOverride: Bool {return self._override != nil}
  /// Clears the value of `override`. Subsequent reads from it will return its default value.
  public mutating func clearOverride() {self._override = nil}

  public var principleTarget: Xray_App_Router_Command_PrincipleTargetInfo {
    get {return _principleTarget ?? Xray_App_Router_Command_PrincipleTargetInfo()}
    set {_principleTarget = newValue}
  }
  /// Returns true if `principleTarget` has been explicitly set.
  public var hasPrincipleTarget: Bool {return self._principleTarget != nil}
  /// Clears the value of `principleTarget`. Subsequent reads from it will return its default value.
  public mutating func clearPrincipleTarget() {self._principleTarget = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _override: Xray_App_Router_Command_OverrideInfo? = nil
  fileprivate var _principleTarget: Xray_App_Router_Command_PrincipleTargetInfo? = nil
}

public struct Xray_App_Router_Command_GetBalancerInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_GetBalancerInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balancer: Xray_App_Router_Command_BalancerMsg {
    get {return _balancer ?? Xray_App_Router_Command_BalancerMsg()}
    set {_balancer = newValue}
  }
  /// Returns true if `balancer` has been explicitly set.
  public var hasBalancer: Bool {return self._balancer != nil}
  /// Clears the value of `balancer`. Subsequent reads from it will return its default value.
  public mutating func clearBalancer() {self._balancer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _balancer: Xray_App_Router_Command_BalancerMsg? = nil
}

public struct Xray_App_Router_Command_OverrideBalancerTargetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balancerTag: String = String()

  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_OverrideBalancerTargetResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_AddRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var config: Xray_Common_Serial_TypedMessage {
    get {return _config ?? Xray_Common_Serial_TypedMessage()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var shouldAppend: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Xray_Common_Serial_TypedMessage? = nil
}

public struct Xray_App_Router_Command_AddRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_RemoveRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ruleTag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_RemoveRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Router_Command_Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.app.router.command"

extension Xray_App_Router_Command_RoutingContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RoutingContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "InboundTag"),
    2: .same(proto: "Network"),
    3: .same(proto: "SourceIPs"),
    4: .same(proto: "TargetIPs"),
    5: .same(proto: "SourcePort"),
    6: .same(proto: "TargetPort"),
    7: .same(proto: "TargetDomain"),
    8: .same(proto: "Protocol"),
    9: .same(proto: "User"),
    10: .same(proto: "Attributes"),
    11: .same(proto: "OutboundGroupTags"),
    12: .same(proto: "OutboundTag"),
    13: .same(proto: "LocalIPs"),
    14: .same(proto: "LocalPort"),
    15: .same(proto: "VlessRoute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inboundTag) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.network) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.sourceIps) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.targetIps) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.sourcePort) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.targetPort) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.targetDomain) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.outboundGroupTags) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.outboundTag) }()
      case 13: try { try decoder.decodeRepeatedBytesField(value: &self.localIps) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.localPort) }()
      case 15: try { try decoder.decodeSingularUInt32Field(value: &self.vlessRoute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inboundTag.isEmpty {
      try visitor.visitSingularStringField(value: self.inboundTag, fieldNumber: 1)
    }
    if self.network != .unknown {
      try visitor.visitSingularEnumField(value: self.network, fieldNumber: 2)
    }
    if !self.sourceIps.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.sourceIps, fieldNumber: 3)
    }
    if !self.targetIps.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.targetIps, fieldNumber: 4)
    }
    if self.sourcePort != 0 {
      try visitor.visitSingularUInt32Field(value: self.sourcePort, fieldNumber: 5)
    }
    if self.targetPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetPort, fieldNumber: 6)
    }
    if !self.targetDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.targetDomain, fieldNumber: 7)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 8)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 9)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 10)
    }
    if !self.outboundGroupTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outboundGroupTags, fieldNumber: 11)
    }
    if !self.outboundTag.isEmpty {
      try visitor.visitSingularStringField(value: self.outboundTag, fieldNumber: 12)
    }
    if !self.localIps.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.localIps, fieldNumber: 13)
    }
    if self.localPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.localPort, fieldNumber: 14)
    }
    if self.vlessRoute != 0 {
      try visitor.visitSingularUInt32Field(value: self.vlessRoute, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_RoutingContext, rhs: Xray_App_Router_Command_RoutingContext) -> Bool {
    if lhs.inboundTag != rhs.inboundTag {return false}
    if lhs.network != rhs.network {return false}
    if lhs.sourceIps != rhs.sourceIps {return false}
    if lhs.targetIps != rhs.targetIps {return false}
    if lhs.sourcePort != rhs.sourcePort {return false}
    if lhs.targetPort != rhs.targetPort {return false}
    if lhs.targetDomain != rhs.targetDomain {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.user != rhs.user {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.outboundGroupTags != rhs.outboundGroupTags {return false}
    if lhs.outboundTag != rhs.outboundTag {return false}
    if lhs.localIps != rhs.localIps {return false}
    if lhs.localPort != rhs.localPort {return false}
    if lhs.vlessRoute != rhs.vlessRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_SubscribeRoutingStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeRoutingStatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FieldSelectors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.fieldSelectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldSelectors.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fieldSelectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_SubscribeRoutingStatsRequest, rhs: Xray_App_Router_Command_SubscribeRoutingStatsRequest) -> Bool {
    if lhs.fieldSelectors != rhs.fieldSelectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_TestRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestRouteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RoutingContext"),
    2: .same(proto: "FieldSelectors"),
    3: .same(proto: "PublishResult"),
  ]

  fileprivate class _StorageClass {
    var _routingContext: Xray_App_Router_Command_RoutingContext? = nil
    var _fieldSelectors: [String] = []
    var _publishResult: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _routingContext = source._routingContext
      _fieldSelectors = source._fieldSelectors
      _publishResult = source._publishResult
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._routingContext) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._fieldSelectors) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._publishResult) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._routingContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._fieldSelectors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._fieldSelectors, fieldNumber: 2)
      }
      if _storage._publishResult != false {
        try visitor.visitSingularBoolField(value: _storage._publishResult, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_TestRouteRequest, rhs: Xray_App_Router_Command_TestRouteRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._routingContext != rhs_storage._routingContext {return false}
        if _storage._fieldSelectors != rhs_storage._fieldSelectors {return false}
        if _storage._publishResult != rhs_storage._publishResult {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_PrincipleTargetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrincipleTargetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_PrincipleTargetInfo, rhs: Xray_App_Router_Command_PrincipleTargetInfo) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_OverrideInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OverrideInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_OverrideInfo, rhs: Xray_App_Router_Command_OverrideInfo) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_BalancerMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BalancerMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "override"),
    6: .standard(proto: "principle_target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularMessageField(value: &self._override) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._principleTarget) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._override {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._principleTarget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_BalancerMsg, rhs: Xray_App_Router_Command_BalancerMsg) -> Bool {
    if lhs._override != rhs._override {return false}
    if lhs._principleTarget != rhs._principleTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_GetBalancerInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBalancerInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_GetBalancerInfoRequest, rhs: Xray_App_Router_Command_GetBalancerInfoRequest) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_GetBalancerInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBalancerInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balancer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._balancer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._balancer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_GetBalancerInfoResponse, rhs: Xray_App_Router_Command_GetBalancerInfoResponse) -> Bool {
    if lhs._balancer != rhs._balancer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_OverrideBalancerTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OverrideBalancerTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balancerTag"),
    2: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.balancerTag) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.balancerTag.isEmpty {
      try visitor.visitSingularStringField(value: self.balancerTag, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_OverrideBalancerTargetRequest, rhs: Xray_App_Router_Command_OverrideBalancerTargetRequest) -> Bool {
    if lhs.balancerTag != rhs.balancerTag {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_OverrideBalancerTargetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OverrideBalancerTargetResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_OverrideBalancerTargetResponse, rhs: Xray_App_Router_Command_OverrideBalancerTargetResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_AddRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddRuleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "shouldAppend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.shouldAppend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.shouldAppend != false {
      try visitor.visitSingularBoolField(value: self.shouldAppend, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_AddRuleRequest, rhs: Xray_App_Router_Command_AddRuleRequest) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.shouldAppend != rhs.shouldAppend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_AddRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_AddRuleResponse, rhs: Xray_App_Router_Command_AddRuleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_RemoveRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveRuleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ruleTag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ruleTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ruleTag.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleTag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_RemoveRuleRequest, rhs: Xray_App_Router_Command_RemoveRuleRequest) -> Bool {
    if lhs.ruleTag != rhs.ruleTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_RemoveRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_RemoveRuleResponse, rhs: Xray_App_Router_Command_RemoveRuleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Router_Command_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Router_Command_Config, rhs: Xray_App_Router_Command_Config) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
