// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transport/internet/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Xray_Transport_Internet_DomainStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case asIs // = 0
  case useIp // = 1
  case useIp4 // = 2
  case useIp6 // = 3
  case useIp46 // = 4
  case useIp64 // = 5
  case forceIp // = 6
  case forceIp4 // = 7
  case forceIp6 // = 8
  case forceIp46 // = 9
  case forceIp64 // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .asIs
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .asIs
    case 1: self = .useIp
    case 2: self = .useIp4
    case 3: self = .useIp6
    case 4: self = .useIp46
    case 5: self = .useIp64
    case 6: self = .forceIp
    case 7: self = .forceIp4
    case 8: self = .forceIp6
    case 9: self = .forceIp46
    case 10: self = .forceIp64
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .asIs: return 0
    case .useIp: return 1
    case .useIp4: return 2
    case .useIp6: return 3
    case .useIp46: return 4
    case .useIp64: return 5
    case .forceIp: return 6
    case .forceIp4: return 7
    case .forceIp6: return 8
    case .forceIp46: return 9
    case .forceIp64: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xray_Transport_Internet_DomainStrategy] = [
    .asIs,
    .useIp,
    .useIp4,
    .useIp6,
    .useIp46,
    .useIp64,
    .forceIp,
    .forceIp4,
    .forceIp6,
    .forceIp46,
    .forceIp64,
  ]

}

public enum Xray_Transport_Internet_AddressPortStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case srvPortOnly // = 1
  case srvAddressOnly // = 2
  case srvPortAndAddress // = 3
  case txtPortOnly // = 4
  case txtAddressOnly // = 5
  case txtPortAndAddress // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .srvPortOnly
    case 2: self = .srvAddressOnly
    case 3: self = .srvPortAndAddress
    case 4: self = .txtPortOnly
    case 5: self = .txtAddressOnly
    case 6: self = .txtPortAndAddress
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .srvPortOnly: return 1
    case .srvAddressOnly: return 2
    case .srvPortAndAddress: return 3
    case .txtPortOnly: return 4
    case .txtAddressOnly: return 5
    case .txtPortAndAddress: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xray_Transport_Internet_AddressPortStrategy] = [
    .none,
    .srvPortOnly,
    .srvAddressOnly,
    .srvPortAndAddress,
    .txtPortOnly,
    .txtAddressOnly,
    .txtPortAndAddress,
  ]

}

public struct Xray_Transport_Internet_TransportConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transport protocol name.
  public var protocolName: String = String()

  /// Specific transport protocol settings.
  public var settings: Xray_Common_Serial_TypedMessage {
    get {return _settings ?? Xray_Common_Serial_TypedMessage()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  public var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  public mutating func clearSettings() {self._settings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _settings: Xray_Common_Serial_TypedMessage? = nil
}

public struct Xray_Transport_Internet_StreamConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Xray_Common_Net_IPOrDomain {
    get {return _address ?? Xray_Common_Net_IPOrDomain()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var port: UInt32 = 0

  /// Effective network.
  public var protocolName: String = String()

  public var transportSettings: [Xray_Transport_Internet_TransportConfig] = []

  /// Type of security. Must be a message name of the settings proto.
  public var securityType: String = String()

  /// Transport security settings. They can be either TLS or REALITY.
  public var securitySettings: [Xray_Common_Serial_TypedMessage] = []

  public var socketSettings: Xray_Transport_Internet_SocketConfig {
    get {return _socketSettings ?? Xray_Transport_Internet_SocketConfig()}
    set {_socketSettings = newValue}
  }
  /// Returns true if `socketSettings` has been explicitly set.
  public var hasSocketSettings: Bool {return self._socketSettings != nil}
  /// Clears the value of `socketSettings`. Subsequent reads from it will return its default value.
  public mutating func clearSocketSettings() {self._socketSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Xray_Common_Net_IPOrDomain? = nil
  fileprivate var _socketSettings: Xray_Transport_Internet_SocketConfig? = nil
}

public struct Xray_Transport_Internet_ProxyConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tag: String = String()

  public var transportLayerProxy: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Transport_Internet_CustomSockopt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var system: String = String()

  public var network: String = String()

  public var level: String = String()

  public var opt: String = String()

  public var value: String = String()

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SocketConfig is options to be applied on network sockets.
public struct Xray_Transport_Internet_SocketConfig: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mark of the connection. If non-zero, the value will be set to SO_MARK.
  public var mark: Int32 {
    get {return _storage._mark}
    set {_uniqueStorage()._mark = newValue}
  }

  /// TFO is the state of TFO settings.
  public var tfo: Int32 {
    get {return _storage._tfo}
    set {_uniqueStorage()._tfo = newValue}
  }

  /// TProxy is for enabling TProxy socket option.
  public var tproxy: Xray_Transport_Internet_SocketConfig.TProxyMode {
    get {return _storage._tproxy}
    set {_uniqueStorage()._tproxy = newValue}
  }

  /// ReceiveOriginalDestAddress is for enabling IP_RECVORIGDSTADDR socket
  /// option. This option is for UDP only.
  public var receiveOriginalDestAddress: Bool {
    get {return _storage._receiveOriginalDestAddress}
    set {_uniqueStorage()._receiveOriginalDestAddress = newValue}
  }

  public var bindAddress: Data {
    get {return _storage._bindAddress}
    set {_uniqueStorage()._bindAddress = newValue}
  }

  public var bindPort: UInt32 {
    get {return _storage._bindPort}
    set {_uniqueStorage()._bindPort = newValue}
  }

  public var acceptProxyProtocol: Bool {
    get {return _storage._acceptProxyProtocol}
    set {_uniqueStorage()._acceptProxyProtocol = newValue}
  }

  public var domainStrategy: Xray_Transport_Internet_DomainStrategy {
    get {return _storage._domainStrategy}
    set {_uniqueStorage()._domainStrategy = newValue}
  }

  public var dialerProxy: String {
    get {return _storage._dialerProxy}
    set {_uniqueStorage()._dialerProxy = newValue}
  }

  public var tcpKeepAliveInterval: Int32 {
    get {return _storage._tcpKeepAliveInterval}
    set {_uniqueStorage()._tcpKeepAliveInterval = newValue}
  }

  public var tcpKeepAliveIdle: Int32 {
    get {return _storage._tcpKeepAliveIdle}
    set {_uniqueStorage()._tcpKeepAliveIdle = newValue}
  }

  public var tcpCongestion: String {
    get {return _storage._tcpCongestion}
    set {_uniqueStorage()._tcpCongestion = newValue}
  }

  public var interface: String {
    get {return _storage._interface}
    set {_uniqueStorage()._interface = newValue}
  }

  public var v6Only: Bool {
    get {return _storage._v6Only}
    set {_uniqueStorage()._v6Only = newValue}
  }

  public var tcpWindowClamp: Int32 {
    get {return _storage._tcpWindowClamp}
    set {_uniqueStorage()._tcpWindowClamp = newValue}
  }

  public var tcpUserTimeout: Int32 {
    get {return _storage._tcpUserTimeout}
    set {_uniqueStorage()._tcpUserTimeout = newValue}
  }

  public var tcpMaxSeg: Int32 {
    get {return _storage._tcpMaxSeg}
    set {_uniqueStorage()._tcpMaxSeg = newValue}
  }

  public var penetrate: Bool {
    get {return _storage._penetrate}
    set {_uniqueStorage()._penetrate = newValue}
  }

  public var tcpMptcp: Bool {
    get {return _storage._tcpMptcp}
    set {_uniqueStorage()._tcpMptcp = newValue}
  }

  public var customSockopt: [Xray_Transport_Internet_CustomSockopt] {
    get {return _storage._customSockopt}
    set {_uniqueStorage()._customSockopt = newValue}
  }

  public var addressPortStrategy: Xray_Transport_Internet_AddressPortStrategy {
    get {return _storage._addressPortStrategy}
    set {_uniqueStorage()._addressPortStrategy = newValue}
  }

  public var happyEyeballs: Xray_Transport_Internet_HappyEyeballsConfig {
    get {return _storage._happyEyeballs ?? Xray_Transport_Internet_HappyEyeballsConfig()}
    set {_uniqueStorage()._happyEyeballs = newValue}
  }
  /// Returns true if `happyEyeballs` has been explicitly set.
  public var hasHappyEyeballs: Bool {return _storage._happyEyeballs != nil}
  /// Clears the value of `happyEyeballs`. Subsequent reads from it will return its default value.
  public mutating func clearHappyEyeballs() {_uniqueStorage()._happyEyeballs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TProxyMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// TProxy is off.
    case off // = 0

    /// TProxy mode.
    case tproxy // = 1

    /// Redirect mode.
    case redirect // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .off
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .off
      case 1: self = .tproxy
      case 2: self = .redirect
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .off: return 0
      case .tproxy: return 1
      case .redirect: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Xray_Transport_Internet_SocketConfig.TProxyMode] = [
      .off,
      .tproxy,
      .redirect,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Xray_Transport_Internet_HappyEyeballsConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var prioritizeIpv6: Bool = false

  public var interleave: UInt32 = 0

  public var tryDelayMs: UInt64 = 0

  public var maxConcurrentTry: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.transport.internet"

extension Xray_Transport_Internet_DomainStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AS_IS"),
    1: .same(proto: "USE_IP"),
    2: .same(proto: "USE_IP4"),
    3: .same(proto: "USE_IP6"),
    4: .same(proto: "USE_IP46"),
    5: .same(proto: "USE_IP64"),
    6: .same(proto: "FORCE_IP"),
    7: .same(proto: "FORCE_IP4"),
    8: .same(proto: "FORCE_IP6"),
    9: .same(proto: "FORCE_IP46"),
    10: .same(proto: "FORCE_IP64"),
  ]
}

extension Xray_Transport_Internet_AddressPortStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "SrvPortOnly"),
    2: .same(proto: "SrvAddressOnly"),
    3: .same(proto: "SrvPortAndAddress"),
    4: .same(proto: "TxtPortOnly"),
    5: .same(proto: "TxtAddressOnly"),
    6: .same(proto: "TxtPortAndAddress"),
  ]
}

extension Xray_Transport_Internet_TransportConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransportConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "protocol_name"),
    2: .same(proto: "settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.protocolName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.protocolName.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_TransportConfig, rhs: Xray_Transport_Internet_TransportConfig) -> Bool {
    if lhs.protocolName != rhs.protocolName {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_StreamConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .same(proto: "address"),
    9: .same(proto: "port"),
    5: .standard(proto: "protocol_name"),
    2: .standard(proto: "transport_settings"),
    3: .standard(proto: "security_type"),
    4: .standard(proto: "security_settings"),
    6: .standard(proto: "socket_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transportSettings) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.securityType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.securitySettings) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.protocolName) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._socketSettings) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transportSettings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transportSettings, fieldNumber: 2)
    }
    if !self.securityType.isEmpty {
      try visitor.visitSingularStringField(value: self.securityType, fieldNumber: 3)
    }
    if !self.securitySettings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.securitySettings, fieldNumber: 4)
    }
    if !self.protocolName.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolName, fieldNumber: 5)
    }
    try { if let v = self._socketSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_StreamConfig, rhs: Xray_Transport_Internet_StreamConfig) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.port != rhs.port {return false}
    if lhs.protocolName != rhs.protocolName {return false}
    if lhs.transportSettings != rhs.transportSettings {return false}
    if lhs.securityType != rhs.securityType {return false}
    if lhs.securitySettings != rhs.securitySettings {return false}
    if lhs._socketSettings != rhs._socketSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_ProxyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProxyConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "transportLayerProxy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.transportLayerProxy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    if self.transportLayerProxy != false {
      try visitor.visitSingularBoolField(value: self.transportLayerProxy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_ProxyConfig, rhs: Xray_Transport_Internet_ProxyConfig) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.transportLayerProxy != rhs.transportLayerProxy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_CustomSockopt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomSockopt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "system"),
    2: .same(proto: "network"),
    3: .same(proto: "level"),
    4: .same(proto: "opt"),
    5: .same(proto: "value"),
    6: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.system) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.level) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.opt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.system.isEmpty {
      try visitor.visitSingularStringField(value: self.system, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    if !self.level.isEmpty {
      try visitor.visitSingularStringField(value: self.level, fieldNumber: 3)
    }
    if !self.opt.isEmpty {
      try visitor.visitSingularStringField(value: self.opt, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 5)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_CustomSockopt, rhs: Xray_Transport_Internet_CustomSockopt) -> Bool {
    if lhs.system != rhs.system {return false}
    if lhs.network != rhs.network {return false}
    if lhs.level != rhs.level {return false}
    if lhs.opt != rhs.opt {return false}
    if lhs.value != rhs.value {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_SocketConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SocketConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mark"),
    2: .same(proto: "tfo"),
    3: .same(proto: "tproxy"),
    4: .standard(proto: "receive_original_dest_address"),
    5: .standard(proto: "bind_address"),
    6: .standard(proto: "bind_port"),
    7: .standard(proto: "accept_proxy_protocol"),
    8: .standard(proto: "domain_strategy"),
    9: .standard(proto: "dialer_proxy"),
    10: .standard(proto: "tcp_keep_alive_interval"),
    11: .standard(proto: "tcp_keep_alive_idle"),
    12: .standard(proto: "tcp_congestion"),
    13: .same(proto: "interface"),
    14: .same(proto: "v6only"),
    15: .standard(proto: "tcp_window_clamp"),
    16: .standard(proto: "tcp_user_timeout"),
    17: .standard(proto: "tcp_max_seg"),
    18: .same(proto: "penetrate"),
    19: .standard(proto: "tcp_mptcp"),
    20: .same(proto: "customSockopt"),
    21: .standard(proto: "address_port_strategy"),
    22: .standard(proto: "happy_eyeballs"),
  ]

  fileprivate class _StorageClass {
    var _mark: Int32 = 0
    var _tfo: Int32 = 0
    var _tproxy: Xray_Transport_Internet_SocketConfig.TProxyMode = .off
    var _receiveOriginalDestAddress: Bool = false
    var _bindAddress: Data = Data()
    var _bindPort: UInt32 = 0
    var _acceptProxyProtocol: Bool = false
    var _domainStrategy: Xray_Transport_Internet_DomainStrategy = .asIs
    var _dialerProxy: String = String()
    var _tcpKeepAliveInterval: Int32 = 0
    var _tcpKeepAliveIdle: Int32 = 0
    var _tcpCongestion: String = String()
    var _interface: String = String()
    var _v6Only: Bool = false
    var _tcpWindowClamp: Int32 = 0
    var _tcpUserTimeout: Int32 = 0
    var _tcpMaxSeg: Int32 = 0
    var _penetrate: Bool = false
    var _tcpMptcp: Bool = false
    var _customSockopt: [Xray_Transport_Internet_CustomSockopt] = []
    var _addressPortStrategy: Xray_Transport_Internet_AddressPortStrategy = .none
    var _happyEyeballs: Xray_Transport_Internet_HappyEyeballsConfig? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _mark = source._mark
      _tfo = source._tfo
      _tproxy = source._tproxy
      _receiveOriginalDestAddress = source._receiveOriginalDestAddress
      _bindAddress = source._bindAddress
      _bindPort = source._bindPort
      _acceptProxyProtocol = source._acceptProxyProtocol
      _domainStrategy = source._domainStrategy
      _dialerProxy = source._dialerProxy
      _tcpKeepAliveInterval = source._tcpKeepAliveInterval
      _tcpKeepAliveIdle = source._tcpKeepAliveIdle
      _tcpCongestion = source._tcpCongestion
      _interface = source._interface
      _v6Only = source._v6Only
      _tcpWindowClamp = source._tcpWindowClamp
      _tcpUserTimeout = source._tcpUserTimeout
      _tcpMaxSeg = source._tcpMaxSeg
      _penetrate = source._penetrate
      _tcpMptcp = source._tcpMptcp
      _customSockopt = source._customSockopt
      _addressPortStrategy = source._addressPortStrategy
      _happyEyeballs = source._happyEyeballs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._mark) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._tfo) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._tproxy) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._receiveOriginalDestAddress) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._bindAddress) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._bindPort) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._acceptProxyProtocol) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._domainStrategy) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._dialerProxy) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._tcpKeepAliveInterval) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._tcpKeepAliveIdle) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._tcpCongestion) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._interface) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._v6Only) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._tcpWindowClamp) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._tcpUserTimeout) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._tcpMaxSeg) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._penetrate) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._tcpMptcp) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._customSockopt) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._addressPortStrategy) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._happyEyeballs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._mark != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mark, fieldNumber: 1)
      }
      if _storage._tfo != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tfo, fieldNumber: 2)
      }
      if _storage._tproxy != .off {
        try visitor.visitSingularEnumField(value: _storage._tproxy, fieldNumber: 3)
      }
      if _storage._receiveOriginalDestAddress != false {
        try visitor.visitSingularBoolField(value: _storage._receiveOriginalDestAddress, fieldNumber: 4)
      }
      if !_storage._bindAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bindAddress, fieldNumber: 5)
      }
      if _storage._bindPort != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bindPort, fieldNumber: 6)
      }
      if _storage._acceptProxyProtocol != false {
        try visitor.visitSingularBoolField(value: _storage._acceptProxyProtocol, fieldNumber: 7)
      }
      if _storage._domainStrategy != .asIs {
        try visitor.visitSingularEnumField(value: _storage._domainStrategy, fieldNumber: 8)
      }
      if !_storage._dialerProxy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dialerProxy, fieldNumber: 9)
      }
      if _storage._tcpKeepAliveInterval != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tcpKeepAliveInterval, fieldNumber: 10)
      }
      if _storage._tcpKeepAliveIdle != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tcpKeepAliveIdle, fieldNumber: 11)
      }
      if !_storage._tcpCongestion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tcpCongestion, fieldNumber: 12)
      }
      if !_storage._interface.isEmpty {
        try visitor.visitSingularStringField(value: _storage._interface, fieldNumber: 13)
      }
      if _storage._v6Only != false {
        try visitor.visitSingularBoolField(value: _storage._v6Only, fieldNumber: 14)
      }
      if _storage._tcpWindowClamp != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tcpWindowClamp, fieldNumber: 15)
      }
      if _storage._tcpUserTimeout != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tcpUserTimeout, fieldNumber: 16)
      }
      if _storage._tcpMaxSeg != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tcpMaxSeg, fieldNumber: 17)
      }
      if _storage._penetrate != false {
        try visitor.visitSingularBoolField(value: _storage._penetrate, fieldNumber: 18)
      }
      if _storage._tcpMptcp != false {
        try visitor.visitSingularBoolField(value: _storage._tcpMptcp, fieldNumber: 19)
      }
      if !_storage._customSockopt.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customSockopt, fieldNumber: 20)
      }
      if _storage._addressPortStrategy != .none {
        try visitor.visitSingularEnumField(value: _storage._addressPortStrategy, fieldNumber: 21)
      }
      try { if let v = _storage._happyEyeballs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_SocketConfig, rhs: Xray_Transport_Internet_SocketConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mark != rhs_storage._mark {return false}
        if _storage._tfo != rhs_storage._tfo {return false}
        if _storage._tproxy != rhs_storage._tproxy {return false}
        if _storage._receiveOriginalDestAddress != rhs_storage._receiveOriginalDestAddress {return false}
        if _storage._bindAddress != rhs_storage._bindAddress {return false}
        if _storage._bindPort != rhs_storage._bindPort {return false}
        if _storage._acceptProxyProtocol != rhs_storage._acceptProxyProtocol {return false}
        if _storage._domainStrategy != rhs_storage._domainStrategy {return false}
        if _storage._dialerProxy != rhs_storage._dialerProxy {return false}
        if _storage._tcpKeepAliveInterval != rhs_storage._tcpKeepAliveInterval {return false}
        if _storage._tcpKeepAliveIdle != rhs_storage._tcpKeepAliveIdle {return false}
        if _storage._tcpCongestion != rhs_storage._tcpCongestion {return false}
        if _storage._interface != rhs_storage._interface {return false}
        if _storage._v6Only != rhs_storage._v6Only {return false}
        if _storage._tcpWindowClamp != rhs_storage._tcpWindowClamp {return false}
        if _storage._tcpUserTimeout != rhs_storage._tcpUserTimeout {return false}
        if _storage._tcpMaxSeg != rhs_storage._tcpMaxSeg {return false}
        if _storage._penetrate != rhs_storage._penetrate {return false}
        if _storage._tcpMptcp != rhs_storage._tcpMptcp {return false}
        if _storage._customSockopt != rhs_storage._customSockopt {return false}
        if _storage._addressPortStrategy != rhs_storage._addressPortStrategy {return false}
        if _storage._happyEyeballs != rhs_storage._happyEyeballs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_SocketConfig.TProxyMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Off"),
    1: .same(proto: "TProxy"),
    2: .same(proto: "Redirect"),
  ]
}

extension Xray_Transport_Internet_HappyEyeballsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HappyEyeballsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prioritize_ipv6"),
    2: .same(proto: "interleave"),
    3: .standard(proto: "try_delayMs"),
    4: .standard(proto: "max_concurrent_try"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.prioritizeIpv6) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.interleave) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.tryDelayMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxConcurrentTry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.prioritizeIpv6 != false {
      try visitor.visitSingularBoolField(value: self.prioritizeIpv6, fieldNumber: 1)
    }
    if self.interleave != 0 {
      try visitor.visitSingularUInt32Field(value: self.interleave, fieldNumber: 2)
    }
    if self.tryDelayMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.tryDelayMs, fieldNumber: 3)
    }
    if self.maxConcurrentTry != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxConcurrentTry, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_HappyEyeballsConfig, rhs: Xray_Transport_Internet_HappyEyeballsConfig) -> Bool {
    if lhs.prioritizeIpv6 != rhs.prioritizeIpv6 {return false}
    if lhs.interleave != rhs.interleave {return false}
    if lhs.tryDelayMs != rhs.tryDelayMs {return false}
    if lhs.maxConcurrentTry != rhs.maxConcurrentTry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
