// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transport/internet/reality/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_Transport_Internet_Reality_Config: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var show: Bool {
    get {return _storage._show}
    set {_uniqueStorage()._show = newValue}
  }

  public var dest: String {
    get {return _storage._dest}
    set {_uniqueStorage()._dest = newValue}
  }

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var xver: UInt64 {
    get {return _storage._xver}
    set {_uniqueStorage()._xver = newValue}
  }

  public var serverNames: [String] {
    get {return _storage._serverNames}
    set {_uniqueStorage()._serverNames = newValue}
  }

  public var privateKey: Data {
    get {return _storage._privateKey}
    set {_uniqueStorage()._privateKey = newValue}
  }

  public var minClientVer: Data {
    get {return _storage._minClientVer}
    set {_uniqueStorage()._minClientVer = newValue}
  }

  public var maxClientVer: Data {
    get {return _storage._maxClientVer}
    set {_uniqueStorage()._maxClientVer = newValue}
  }

  public var maxTimeDiff: UInt64 {
    get {return _storage._maxTimeDiff}
    set {_uniqueStorage()._maxTimeDiff = newValue}
  }

  public var shortIds: [Data] {
    get {return _storage._shortIds}
    set {_uniqueStorage()._shortIds = newValue}
  }

  public var mldsa65Seed: Data {
    get {return _storage._mldsa65Seed}
    set {_uniqueStorage()._mldsa65Seed = newValue}
  }

  public var limitFallbackUpload: Xray_Transport_Internet_Reality_LimitFallback {
    get {return _storage._limitFallbackUpload ?? Xray_Transport_Internet_Reality_LimitFallback()}
    set {_uniqueStorage()._limitFallbackUpload = newValue}
  }
  /// Returns true if `limitFallbackUpload` has been explicitly set.
  public var hasLimitFallbackUpload: Bool {return _storage._limitFallbackUpload != nil}
  /// Clears the value of `limitFallbackUpload`. Subsequent reads from it will return its default value.
  public mutating func clearLimitFallbackUpload() {_uniqueStorage()._limitFallbackUpload = nil}

  public var limitFallbackDownload: Xray_Transport_Internet_Reality_LimitFallback {
    get {return _storage._limitFallbackDownload ?? Xray_Transport_Internet_Reality_LimitFallback()}
    set {_uniqueStorage()._limitFallbackDownload = newValue}
  }
  /// Returns true if `limitFallbackDownload` has been explicitly set.
  public var hasLimitFallbackDownload: Bool {return _storage._limitFallbackDownload != nil}
  /// Clears the value of `limitFallbackDownload`. Subsequent reads from it will return its default value.
  public mutating func clearLimitFallbackDownload() {_uniqueStorage()._limitFallbackDownload = nil}

  public var fingerprint: String {
    get {return _storage._fingerprint}
    set {_uniqueStorage()._fingerprint = newValue}
  }

  public var serverName: String {
    get {return _storage._serverName}
    set {_uniqueStorage()._serverName = newValue}
  }

  public var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  public var shortID: Data {
    get {return _storage._shortID}
    set {_uniqueStorage()._shortID = newValue}
  }

  public var mldsa65Verify: Data {
    get {return _storage._mldsa65Verify}
    set {_uniqueStorage()._mldsa65Verify = newValue}
  }

  public var spiderX: String {
    get {return _storage._spiderX}
    set {_uniqueStorage()._spiderX = newValue}
  }

  public var spiderY: [Int64] {
    get {return _storage._spiderY}
    set {_uniqueStorage()._spiderY = newValue}
  }

  public var masterKeyLog: String {
    get {return _storage._masterKeyLog}
    set {_uniqueStorage()._masterKeyLog = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Xray_Transport_Internet_Reality_LimitFallback: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var afterBytes: UInt64 = 0

  public var bytesPerSec: UInt64 = 0

  public var burstBytesPerSec: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.transport.internet.reality"

extension Xray_Transport_Internet_Reality_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "show"),
    2: .same(proto: "dest"),
    3: .same(proto: "type"),
    4: .same(proto: "xver"),
    5: .standard(proto: "server_names"),
    6: .standard(proto: "private_key"),
    7: .standard(proto: "min_client_ver"),
    8: .standard(proto: "max_client_ver"),
    9: .standard(proto: "max_time_diff"),
    10: .standard(proto: "short_ids"),
    11: .standard(proto: "mldsa65_seed"),
    12: .standard(proto: "limit_fallback_upload"),
    13: .standard(proto: "limit_fallback_download"),
    21: .same(proto: "Fingerprint"),
    22: .standard(proto: "server_name"),
    23: .standard(proto: "public_key"),
    24: .standard(proto: "short_id"),
    25: .standard(proto: "mldsa65_verify"),
    26: .standard(proto: "spider_x"),
    27: .standard(proto: "spider_y"),
    31: .standard(proto: "master_key_log"),
  ]

  fileprivate class _StorageClass {
    var _show: Bool = false
    var _dest: String = String()
    var _type: String = String()
    var _xver: UInt64 = 0
    var _serverNames: [String] = []
    var _privateKey: Data = Data()
    var _minClientVer: Data = Data()
    var _maxClientVer: Data = Data()
    var _maxTimeDiff: UInt64 = 0
    var _shortIds: [Data] = []
    var _mldsa65Seed: Data = Data()
    var _limitFallbackUpload: Xray_Transport_Internet_Reality_LimitFallback? = nil
    var _limitFallbackDownload: Xray_Transport_Internet_Reality_LimitFallback? = nil
    var _fingerprint: String = String()
    var _serverName: String = String()
    var _publicKey: Data = Data()
    var _shortID: Data = Data()
    var _mldsa65Verify: Data = Data()
    var _spiderX: String = String()
    var _spiderY: [Int64] = []
    var _masterKeyLog: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _show = source._show
      _dest = source._dest
      _type = source._type
      _xver = source._xver
      _serverNames = source._serverNames
      _privateKey = source._privateKey
      _minClientVer = source._minClientVer
      _maxClientVer = source._maxClientVer
      _maxTimeDiff = source._maxTimeDiff
      _shortIds = source._shortIds
      _mldsa65Seed = source._mldsa65Seed
      _limitFallbackUpload = source._limitFallbackUpload
      _limitFallbackDownload = source._limitFallbackDownload
      _fingerprint = source._fingerprint
      _serverName = source._serverName
      _publicKey = source._publicKey
      _shortID = source._shortID
      _mldsa65Verify = source._mldsa65Verify
      _spiderX = source._spiderX
      _spiderY = source._spiderY
      _masterKeyLog = source._masterKeyLog
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._show) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._dest) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._xver) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._serverNames) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._privateKey) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._minClientVer) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._maxClientVer) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxTimeDiff) }()
        case 10: try { try decoder.decodeRepeatedBytesField(value: &_storage._shortIds) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._mldsa65Seed) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._limitFallbackUpload) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._limitFallbackDownload) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._fingerprint) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._serverName) }()
        case 23: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 24: try { try decoder.decodeSingularBytesField(value: &_storage._shortID) }()
        case 25: try { try decoder.decodeSingularBytesField(value: &_storage._mldsa65Verify) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._spiderX) }()
        case 27: try { try decoder.decodeRepeatedInt64Field(value: &_storage._spiderY) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._masterKeyLog) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._show != false {
        try visitor.visitSingularBoolField(value: _storage._show, fieldNumber: 1)
      }
      if !_storage._dest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dest, fieldNumber: 2)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._xver != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._xver, fieldNumber: 4)
      }
      if !_storage._serverNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._serverNames, fieldNumber: 5)
      }
      if !_storage._privateKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._privateKey, fieldNumber: 6)
      }
      if !_storage._minClientVer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._minClientVer, fieldNumber: 7)
      }
      if !_storage._maxClientVer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._maxClientVer, fieldNumber: 8)
      }
      if _storage._maxTimeDiff != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxTimeDiff, fieldNumber: 9)
      }
      if !_storage._shortIds.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._shortIds, fieldNumber: 10)
      }
      if !_storage._mldsa65Seed.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._mldsa65Seed, fieldNumber: 11)
      }
      try { if let v = _storage._limitFallbackUpload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._limitFallbackDownload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._fingerprint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fingerprint, fieldNumber: 21)
      }
      if !_storage._serverName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverName, fieldNumber: 22)
      }
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 23)
      }
      if !_storage._shortID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._shortID, fieldNumber: 24)
      }
      if !_storage._mldsa65Verify.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._mldsa65Verify, fieldNumber: 25)
      }
      if !_storage._spiderX.isEmpty {
        try visitor.visitSingularStringField(value: _storage._spiderX, fieldNumber: 26)
      }
      if !_storage._spiderY.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._spiderY, fieldNumber: 27)
      }
      if !_storage._masterKeyLog.isEmpty {
        try visitor.visitSingularStringField(value: _storage._masterKeyLog, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Reality_Config, rhs: Xray_Transport_Internet_Reality_Config) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._show != rhs_storage._show {return false}
        if _storage._dest != rhs_storage._dest {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._xver != rhs_storage._xver {return false}
        if _storage._serverNames != rhs_storage._serverNames {return false}
        if _storage._privateKey != rhs_storage._privateKey {return false}
        if _storage._minClientVer != rhs_storage._minClientVer {return false}
        if _storage._maxClientVer != rhs_storage._maxClientVer {return false}
        if _storage._maxTimeDiff != rhs_storage._maxTimeDiff {return false}
        if _storage._shortIds != rhs_storage._shortIds {return false}
        if _storage._mldsa65Seed != rhs_storage._mldsa65Seed {return false}
        if _storage._limitFallbackUpload != rhs_storage._limitFallbackUpload {return false}
        if _storage._limitFallbackDownload != rhs_storage._limitFallbackDownload {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._serverName != rhs_storage._serverName {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._shortID != rhs_storage._shortID {return false}
        if _storage._mldsa65Verify != rhs_storage._mldsa65Verify {return false}
        if _storage._spiderX != rhs_storage._spiderX {return false}
        if _storage._spiderY != rhs_storage._spiderY {return false}
        if _storage._masterKeyLog != rhs_storage._masterKeyLog {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Reality_LimitFallback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitFallback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "after_bytes"),
    2: .standard(proto: "bytes_per_sec"),
    3: .standard(proto: "burst_bytes_per_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.afterBytes) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.bytesPerSec) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.burstBytesPerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.afterBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.afterBytes, fieldNumber: 1)
    }
    if self.bytesPerSec != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesPerSec, fieldNumber: 2)
    }
    if self.burstBytesPerSec != 0 {
      try visitor.visitSingularUInt64Field(value: self.burstBytesPerSec, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Reality_LimitFallback, rhs: Xray_Transport_Internet_Reality_LimitFallback) -> Bool {
    if lhs.afterBytes != rhs.afterBytes {return false}
    if lhs.bytesPerSec != rhs.bytesPerSec {return false}
    if lhs.burstBytesPerSec != rhs.burstBytesPerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
