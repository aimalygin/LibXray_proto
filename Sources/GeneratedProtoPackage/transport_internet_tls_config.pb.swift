// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transport/internet/tls/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_Transport_Internet_Tls_Certificate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TLS certificate in x509 format.
  public var certificate: Data = Data()

  /// TLS key in x509 format.
  public var key: Data = Data()

  public var usage: Xray_Transport_Internet_Tls_Certificate.Usage = .encipherment

  public var ocspStapling: UInt64 = 0

  /// TLS certificate path
  public var certificatePath: String = String()

  /// TLS Key path
  public var keyPath: String = String()

  /// If true, one-Time Loading
  public var oneTimeLoading: Bool = false

  public var buildChain: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Usage: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case encipherment // = 0
    case authorityVerify // = 1
    case authorityIssue // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .encipherment
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .encipherment
      case 1: self = .authorityVerify
      case 2: self = .authorityIssue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .encipherment: return 0
      case .authorityVerify: return 1
      case .authorityIssue: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Xray_Transport_Internet_Tls_Certificate.Usage] = [
      .encipherment,
      .authorityVerify,
      .authorityIssue,
    ]

  }

  public init() {}
}

public struct Xray_Transport_Internet_Tls_Config: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not to allow self-signed certificates.
  public var allowInsecure: Bool {
    get {return _storage._allowInsecure}
    set {_uniqueStorage()._allowInsecure = newValue}
  }

  /// List of certificates to be served on server.
  public var certificate: [Xray_Transport_Internet_Tls_Certificate] {
    get {return _storage._certificate}
    set {_uniqueStorage()._certificate = newValue}
  }

  /// Override server name.
  public var serverName: String {
    get {return _storage._serverName}
    set {_uniqueStorage()._serverName = newValue}
  }

  /// Lists of string as ALPN values.
  public var nextProtocol: [String] {
    get {return _storage._nextProtocol}
    set {_uniqueStorage()._nextProtocol = newValue}
  }

  /// Whether or not to enable session (ticket) resumption.
  public var enableSessionResumption: Bool {
    get {return _storage._enableSessionResumption}
    set {_uniqueStorage()._enableSessionResumption = newValue}
  }

  /// If true, root certificates on the system will not be loaded for
  /// verification.
  public var disableSystemRoot: Bool {
    get {return _storage._disableSystemRoot}
    set {_uniqueStorage()._disableSystemRoot = newValue}
  }

  /// The minimum TLS version.
  public var minVersion: String {
    get {return _storage._minVersion}
    set {_uniqueStorage()._minVersion = newValue}
  }

  /// The maximum TLS version.
  public var maxVersion: String {
    get {return _storage._maxVersion}
    set {_uniqueStorage()._maxVersion = newValue}
  }

  /// Specify cipher suites, except for TLS 1.3.
  public var cipherSuites: String {
    get {return _storage._cipherSuites}
    set {_uniqueStorage()._cipherSuites = newValue}
  }

  /// TLS Client Hello fingerprint (uTLS).
  public var fingerprint: String {
    get {return _storage._fingerprint}
    set {_uniqueStorage()._fingerprint = newValue}
  }

  public var rejectUnknownSni: Bool {
    get {return _storage._rejectUnknownSni}
    set {_uniqueStorage()._rejectUnknownSni = newValue}
  }

  /// @Document Some certificate chain sha256 hashes.
  ///@Document After normal validation or allow_insecure, if the server's cert chain hash does not match any of these values, the connection will be aborted.
  ///@Critical
  public var pinnedPeerCertificateChainSha256: [Data] {
    get {return _storage._pinnedPeerCertificateChainSha256}
    set {_uniqueStorage()._pinnedPeerCertificateChainSha256 = newValue}
  }

  /// @Document Some certificate public key sha256 hashes.
  ///@Document After normal validation (required), if one of certs in verified chain matches one of these values, the connection will be eventually accepted.
  ///@Critical
  public var pinnedPeerCertificatePublicKeySha256: [Data] {
    get {return _storage._pinnedPeerCertificatePublicKeySha256}
    set {_uniqueStorage()._pinnedPeerCertificatePublicKeySha256 = newValue}
  }

  public var masterKeyLog: String {
    get {return _storage._masterKeyLog}
    set {_uniqueStorage()._masterKeyLog = newValue}
  }

  /// Lists of string as CurvePreferences values.
  public var curvePreferences: [String] {
    get {return _storage._curvePreferences}
    set {_uniqueStorage()._curvePreferences = newValue}
  }

  /// @Document Replaces server_name to verify the peer cert.
  ///@Document After allow_insecure (automatically), if the server's cert can't be verified by any of these names, pinned_peer_certificate_chain_sha256 will be tried.
  ///@Critical
  public var verifyPeerCertInNames: [String] {
    get {return _storage._verifyPeerCertInNames}
    set {_uniqueStorage()._verifyPeerCertInNames = newValue}
  }

  public var echServerKeys: Data {
    get {return _storage._echServerKeys}
    set {_uniqueStorage()._echServerKeys = newValue}
  }

  public var echConfigList: String {
    get {return _storage._echConfigList}
    set {_uniqueStorage()._echConfigList = newValue}
  }

  public var echForceQuery: String {
    get {return _storage._echForceQuery}
    set {_uniqueStorage()._echForceQuery = newValue}
  }

  public var echSocketSettings: Xray_Transport_Internet_SocketConfig {
    get {return _storage._echSocketSettings ?? Xray_Transport_Internet_SocketConfig()}
    set {_uniqueStorage()._echSocketSettings = newValue}
  }
  /// Returns true if `echSocketSettings` has been explicitly set.
  public var hasEchSocketSettings: Bool {return _storage._echSocketSettings != nil}
  /// Clears the value of `echSocketSettings`. Subsequent reads from it will return its default value.
  public mutating func clearEchSocketSettings() {_uniqueStorage()._echSocketSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.transport.internet.tls"

extension Xray_Transport_Internet_Tls_Certificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Certificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certificate"),
    2: .same(proto: "key"),
    3: .same(proto: "usage"),
    4: .standard(proto: "ocsp_stapling"),
    5: .standard(proto: "certificate_path"),
    6: .standard(proto: "key_path"),
    7: .standard(proto: "One_time_loading"),
    8: .standard(proto: "build_chain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.certificate) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.usage) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.ocspStapling) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.certificatePath) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.keyPath) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.oneTimeLoading) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.buildChain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificate, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    if self.usage != .encipherment {
      try visitor.visitSingularEnumField(value: self.usage, fieldNumber: 3)
    }
    if self.ocspStapling != 0 {
      try visitor.visitSingularUInt64Field(value: self.ocspStapling, fieldNumber: 4)
    }
    if !self.certificatePath.isEmpty {
      try visitor.visitSingularStringField(value: self.certificatePath, fieldNumber: 5)
    }
    if !self.keyPath.isEmpty {
      try visitor.visitSingularStringField(value: self.keyPath, fieldNumber: 6)
    }
    if self.oneTimeLoading != false {
      try visitor.visitSingularBoolField(value: self.oneTimeLoading, fieldNumber: 7)
    }
    if self.buildChain != false {
      try visitor.visitSingularBoolField(value: self.buildChain, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Tls_Certificate, rhs: Xray_Transport_Internet_Tls_Certificate) -> Bool {
    if lhs.certificate != rhs.certificate {return false}
    if lhs.key != rhs.key {return false}
    if lhs.usage != rhs.usage {return false}
    if lhs.ocspStapling != rhs.ocspStapling {return false}
    if lhs.certificatePath != rhs.certificatePath {return false}
    if lhs.keyPath != rhs.keyPath {return false}
    if lhs.oneTimeLoading != rhs.oneTimeLoading {return false}
    if lhs.buildChain != rhs.buildChain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Tls_Certificate.Usage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENCIPHERMENT"),
    1: .same(proto: "AUTHORITY_VERIFY"),
    2: .same(proto: "AUTHORITY_ISSUE"),
  ]
}

extension Xray_Transport_Internet_Tls_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_insecure"),
    2: .same(proto: "certificate"),
    3: .standard(proto: "server_name"),
    4: .standard(proto: "next_protocol"),
    5: .standard(proto: "enable_session_resumption"),
    6: .standard(proto: "disable_system_root"),
    7: .standard(proto: "min_version"),
    8: .standard(proto: "max_version"),
    9: .standard(proto: "cipher_suites"),
    11: .same(proto: "fingerprint"),
    12: .standard(proto: "reject_unknown_sni"),
    13: .standard(proto: "pinned_peer_certificate_chain_sha256"),
    14: .standard(proto: "pinned_peer_certificate_public_key_sha256"),
    15: .standard(proto: "master_key_log"),
    16: .standard(proto: "curve_preferences"),
    17: .standard(proto: "verify_peer_cert_in_names"),
    18: .standard(proto: "ech_server_keys"),
    19: .standard(proto: "ech_config_list"),
    20: .standard(proto: "ech_force_query"),
    21: .standard(proto: "ech_socket_settings"),
  ]

  fileprivate class _StorageClass {
    var _allowInsecure: Bool = false
    var _certificate: [Xray_Transport_Internet_Tls_Certificate] = []
    var _serverName: String = String()
    var _nextProtocol: [String] = []
    var _enableSessionResumption: Bool = false
    var _disableSystemRoot: Bool = false
    var _minVersion: String = String()
    var _maxVersion: String = String()
    var _cipherSuites: String = String()
    var _fingerprint: String = String()
    var _rejectUnknownSni: Bool = false
    var _pinnedPeerCertificateChainSha256: [Data] = []
    var _pinnedPeerCertificatePublicKeySha256: [Data] = []
    var _masterKeyLog: String = String()
    var _curvePreferences: [String] = []
    var _verifyPeerCertInNames: [String] = []
    var _echServerKeys: Data = Data()
    var _echConfigList: String = String()
    var _echForceQuery: String = String()
    var _echSocketSettings: Xray_Transport_Internet_SocketConfig? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _allowInsecure = source._allowInsecure
      _certificate = source._certificate
      _serverName = source._serverName
      _nextProtocol = source._nextProtocol
      _enableSessionResumption = source._enableSessionResumption
      _disableSystemRoot = source._disableSystemRoot
      _minVersion = source._minVersion
      _maxVersion = source._maxVersion
      _cipherSuites = source._cipherSuites
      _fingerprint = source._fingerprint
      _rejectUnknownSni = source._rejectUnknownSni
      _pinnedPeerCertificateChainSha256 = source._pinnedPeerCertificateChainSha256
      _pinnedPeerCertificatePublicKeySha256 = source._pinnedPeerCertificatePublicKeySha256
      _masterKeyLog = source._masterKeyLog
      _curvePreferences = source._curvePreferences
      _verifyPeerCertInNames = source._verifyPeerCertInNames
      _echServerKeys = source._echServerKeys
      _echConfigList = source._echConfigList
      _echForceQuery = source._echForceQuery
      _echSocketSettings = source._echSocketSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._allowInsecure) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._certificate) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._serverName) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._nextProtocol) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._enableSessionResumption) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._disableSystemRoot) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._minVersion) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._maxVersion) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._cipherSuites) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._fingerprint) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._rejectUnknownSni) }()
        case 13: try { try decoder.decodeRepeatedBytesField(value: &_storage._pinnedPeerCertificateChainSha256) }()
        case 14: try { try decoder.decodeRepeatedBytesField(value: &_storage._pinnedPeerCertificatePublicKeySha256) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._masterKeyLog) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._curvePreferences) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._verifyPeerCertInNames) }()
        case 18: try { try decoder.decodeSingularBytesField(value: &_storage._echServerKeys) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._echConfigList) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._echForceQuery) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._echSocketSettings) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._allowInsecure != false {
        try visitor.visitSingularBoolField(value: _storage._allowInsecure, fieldNumber: 1)
      }
      if !_storage._certificate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._certificate, fieldNumber: 2)
      }
      if !_storage._serverName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverName, fieldNumber: 3)
      }
      if !_storage._nextProtocol.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._nextProtocol, fieldNumber: 4)
      }
      if _storage._enableSessionResumption != false {
        try visitor.visitSingularBoolField(value: _storage._enableSessionResumption, fieldNumber: 5)
      }
      if _storage._disableSystemRoot != false {
        try visitor.visitSingularBoolField(value: _storage._disableSystemRoot, fieldNumber: 6)
      }
      if !_storage._minVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minVersion, fieldNumber: 7)
      }
      if !_storage._maxVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxVersion, fieldNumber: 8)
      }
      if !_storage._cipherSuites.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cipherSuites, fieldNumber: 9)
      }
      if !_storage._fingerprint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fingerprint, fieldNumber: 11)
      }
      if _storage._rejectUnknownSni != false {
        try visitor.visitSingularBoolField(value: _storage._rejectUnknownSni, fieldNumber: 12)
      }
      if !_storage._pinnedPeerCertificateChainSha256.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._pinnedPeerCertificateChainSha256, fieldNumber: 13)
      }
      if !_storage._pinnedPeerCertificatePublicKeySha256.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._pinnedPeerCertificatePublicKeySha256, fieldNumber: 14)
      }
      if !_storage._masterKeyLog.isEmpty {
        try visitor.visitSingularStringField(value: _storage._masterKeyLog, fieldNumber: 15)
      }
      if !_storage._curvePreferences.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._curvePreferences, fieldNumber: 16)
      }
      if !_storage._verifyPeerCertInNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._verifyPeerCertInNames, fieldNumber: 17)
      }
      if !_storage._echServerKeys.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._echServerKeys, fieldNumber: 18)
      }
      if !_storage._echConfigList.isEmpty {
        try visitor.visitSingularStringField(value: _storage._echConfigList, fieldNumber: 19)
      }
      if !_storage._echForceQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._echForceQuery, fieldNumber: 20)
      }
      try { if let v = _storage._echSocketSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Tls_Config, rhs: Xray_Transport_Internet_Tls_Config) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._allowInsecure != rhs_storage._allowInsecure {return false}
        if _storage._certificate != rhs_storage._certificate {return false}
        if _storage._serverName != rhs_storage._serverName {return false}
        if _storage._nextProtocol != rhs_storage._nextProtocol {return false}
        if _storage._enableSessionResumption != rhs_storage._enableSessionResumption {return false}
        if _storage._disableSystemRoot != rhs_storage._disableSystemRoot {return false}
        if _storage._minVersion != rhs_storage._minVersion {return false}
        if _storage._maxVersion != rhs_storage._maxVersion {return false}
        if _storage._cipherSuites != rhs_storage._cipherSuites {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._rejectUnknownSni != rhs_storage._rejectUnknownSni {return false}
        if _storage._pinnedPeerCertificateChainSha256 != rhs_storage._pinnedPeerCertificateChainSha256 {return false}
        if _storage._pinnedPeerCertificatePublicKeySha256 != rhs_storage._pinnedPeerCertificatePublicKeySha256 {return false}
        if _storage._masterKeyLog != rhs_storage._masterKeyLog {return false}
        if _storage._curvePreferences != rhs_storage._curvePreferences {return false}
        if _storage._verifyPeerCertInNames != rhs_storage._verifyPeerCertInNames {return false}
        if _storage._echServerKeys != rhs_storage._echServerKeys {return false}
        if _storage._echConfigList != rhs_storage._echConfigList {return false}
        if _storage._echForceQuery != rhs_storage._echForceQuery {return false}
        if _storage._echSocketSettings != rhs_storage._echSocketSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
