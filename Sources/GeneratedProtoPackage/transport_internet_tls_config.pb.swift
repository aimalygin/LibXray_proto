// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transport/internet/tls/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_Transport_Internet_Tls_Certificate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TLS certificate in x509 format.
  public var certificate: Data = Data()

  /// TLS key in x509 format.
  public var key: Data = Data()

  public var usage: Xray_Transport_Internet_Tls_Certificate.Usage = .encipherment

  public var ocspStapling: UInt64 = 0

  /// TLS certificate path
  public var certificatePath: String = String()

  /// TLS Key path
  public var keyPath: String = String()

  /// If true, one-Time Loading
  public var oneTimeLoading: Bool = false

  public var buildChain: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Usage: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case encipherment // = 0
    case authorityVerify // = 1
    case authorityIssue // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .encipherment
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .encipherment
      case 1: self = .authorityVerify
      case 2: self = .authorityIssue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .encipherment: return 0
      case .authorityVerify: return 1
      case .authorityIssue: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Xray_Transport_Internet_Tls_Certificate.Usage] = [
      .encipherment,
      .authorityVerify,
      .authorityIssue,
    ]

  }

  public init() {}
}

public struct Xray_Transport_Internet_Tls_Config: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not to allow self-signed certificates.
  public var allowInsecure: Bool = false

  /// List of certificates to be served on server.
  public var certificate: [Xray_Transport_Internet_Tls_Certificate] = []

  /// Override server name.
  public var serverName: String = String()

  /// Lists of string as ALPN values.
  public var nextProtocol: [String] = []

  /// Whether or not to enable session (ticket) resumption.
  public var enableSessionResumption: Bool = false

  /// If true, root certificates on the system will not be loaded for
  /// verification.
  public var disableSystemRoot: Bool = false

  /// The minimum TLS version.
  public var minVersion: String = String()

  /// The maximum TLS version.
  public var maxVersion: String = String()

  /// Specify cipher suites, except for TLS 1.3.
  public var cipherSuites: String = String()

  /// TLS Client Hello fingerprint (uTLS).
  public var fingerprint: String = String()

  public var rejectUnknownSni: Bool = false

  /// @Document A pinned certificate chain sha256 hash.
  ///@Document If the server's hash does not match this value, the connection will be aborted.
  ///@Document This value replace allow_insecure.
  ///@Critical
  public var pinnedPeerCertificateChainSha256: [Data] = []

  /// @Document A pinned certificate public key sha256 hash.
  ///@Document If the server's public key hash does not match this value, the connection will be aborted.
  ///@Document This value replace allow_insecure.
  ///@Critical
  public var pinnedPeerCertificatePublicKeySha256: [Data] = []

  public var masterKeyLog: String = String()

  /// Lists of string as CurvePreferences values.
  public var curvePreferences: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.transport.internet.tls"

extension Xray_Transport_Internet_Tls_Certificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Certificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certificate"),
    2: .same(proto: "key"),
    3: .same(proto: "usage"),
    4: .standard(proto: "ocsp_stapling"),
    5: .standard(proto: "certificate_path"),
    6: .standard(proto: "key_path"),
    7: .standard(proto: "One_time_loading"),
    8: .standard(proto: "build_chain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.certificate) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.usage) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.ocspStapling) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.certificatePath) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.keyPath) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.oneTimeLoading) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.buildChain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificate, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    if self.usage != .encipherment {
      try visitor.visitSingularEnumField(value: self.usage, fieldNumber: 3)
    }
    if self.ocspStapling != 0 {
      try visitor.visitSingularUInt64Field(value: self.ocspStapling, fieldNumber: 4)
    }
    if !self.certificatePath.isEmpty {
      try visitor.visitSingularStringField(value: self.certificatePath, fieldNumber: 5)
    }
    if !self.keyPath.isEmpty {
      try visitor.visitSingularStringField(value: self.keyPath, fieldNumber: 6)
    }
    if self.oneTimeLoading != false {
      try visitor.visitSingularBoolField(value: self.oneTimeLoading, fieldNumber: 7)
    }
    if self.buildChain != false {
      try visitor.visitSingularBoolField(value: self.buildChain, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Tls_Certificate, rhs: Xray_Transport_Internet_Tls_Certificate) -> Bool {
    if lhs.certificate != rhs.certificate {return false}
    if lhs.key != rhs.key {return false}
    if lhs.usage != rhs.usage {return false}
    if lhs.ocspStapling != rhs.ocspStapling {return false}
    if lhs.certificatePath != rhs.certificatePath {return false}
    if lhs.keyPath != rhs.keyPath {return false}
    if lhs.oneTimeLoading != rhs.oneTimeLoading {return false}
    if lhs.buildChain != rhs.buildChain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Tls_Certificate.Usage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENCIPHERMENT"),
    1: .same(proto: "AUTHORITY_VERIFY"),
    2: .same(proto: "AUTHORITY_ISSUE"),
  ]
}

extension Xray_Transport_Internet_Tls_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_insecure"),
    2: .same(proto: "certificate"),
    3: .standard(proto: "server_name"),
    4: .standard(proto: "next_protocol"),
    5: .standard(proto: "enable_session_resumption"),
    6: .standard(proto: "disable_system_root"),
    7: .standard(proto: "min_version"),
    8: .standard(proto: "max_version"),
    9: .standard(proto: "cipher_suites"),
    11: .same(proto: "fingerprint"),
    12: .standard(proto: "reject_unknown_sni"),
    13: .standard(proto: "pinned_peer_certificate_chain_sha256"),
    14: .standard(proto: "pinned_peer_certificate_public_key_sha256"),
    15: .standard(proto: "master_key_log"),
    16: .standard(proto: "curve_preferences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.allowInsecure) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.certificate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverName) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.nextProtocol) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableSessionResumption) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disableSystemRoot) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.minVersion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.maxVersion) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.cipherSuites) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.fingerprint) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.rejectUnknownSni) }()
      case 13: try { try decoder.decodeRepeatedBytesField(value: &self.pinnedPeerCertificateChainSha256) }()
      case 14: try { try decoder.decodeRepeatedBytesField(value: &self.pinnedPeerCertificatePublicKeySha256) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.masterKeyLog) }()
      case 16: try { try decoder.decodeRepeatedStringField(value: &self.curvePreferences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.allowInsecure != false {
      try visitor.visitSingularBoolField(value: self.allowInsecure, fieldNumber: 1)
    }
    if !self.certificate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.certificate, fieldNumber: 2)
    }
    if !self.serverName.isEmpty {
      try visitor.visitSingularStringField(value: self.serverName, fieldNumber: 3)
    }
    if !self.nextProtocol.isEmpty {
      try visitor.visitRepeatedStringField(value: self.nextProtocol, fieldNumber: 4)
    }
    if self.enableSessionResumption != false {
      try visitor.visitSingularBoolField(value: self.enableSessionResumption, fieldNumber: 5)
    }
    if self.disableSystemRoot != false {
      try visitor.visitSingularBoolField(value: self.disableSystemRoot, fieldNumber: 6)
    }
    if !self.minVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minVersion, fieldNumber: 7)
    }
    if !self.maxVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.maxVersion, fieldNumber: 8)
    }
    if !self.cipherSuites.isEmpty {
      try visitor.visitSingularStringField(value: self.cipherSuites, fieldNumber: 9)
    }
    if !self.fingerprint.isEmpty {
      try visitor.visitSingularStringField(value: self.fingerprint, fieldNumber: 11)
    }
    if self.rejectUnknownSni != false {
      try visitor.visitSingularBoolField(value: self.rejectUnknownSni, fieldNumber: 12)
    }
    if !self.pinnedPeerCertificateChainSha256.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.pinnedPeerCertificateChainSha256, fieldNumber: 13)
    }
    if !self.pinnedPeerCertificatePublicKeySha256.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.pinnedPeerCertificatePublicKeySha256, fieldNumber: 14)
    }
    if !self.masterKeyLog.isEmpty {
      try visitor.visitSingularStringField(value: self.masterKeyLog, fieldNumber: 15)
    }
    if !self.curvePreferences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.curvePreferences, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Tls_Config, rhs: Xray_Transport_Internet_Tls_Config) -> Bool {
    if lhs.allowInsecure != rhs.allowInsecure {return false}
    if lhs.certificate != rhs.certificate {return false}
    if lhs.serverName != rhs.serverName {return false}
    if lhs.nextProtocol != rhs.nextProtocol {return false}
    if lhs.enableSessionResumption != rhs.enableSessionResumption {return false}
    if lhs.disableSystemRoot != rhs.disableSystemRoot {return false}
    if lhs.minVersion != rhs.minVersion {return false}
    if lhs.maxVersion != rhs.maxVersion {return false}
    if lhs.cipherSuites != rhs.cipherSuites {return false}
    if lhs.fingerprint != rhs.fingerprint {return false}
    if lhs.rejectUnknownSni != rhs.rejectUnknownSni {return false}
    if lhs.pinnedPeerCertificateChainSha256 != rhs.pinnedPeerCertificateChainSha256 {return false}
    if lhs.pinnedPeerCertificatePublicKeySha256 != rhs.pinnedPeerCertificatePublicKeySha256 {return false}
    if lhs.masterKeyLog != rhs.masterKeyLog {return false}
    if lhs.curvePreferences != rhs.curvePreferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
