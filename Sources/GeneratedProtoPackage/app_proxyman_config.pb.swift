// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app/proxyman/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_App_Proxyman_InboundConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Proxyman_SniffingConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not to enable content sniffing on an inbound connection.
  public var enabled: Bool = false

  /// Override target destination if sniff'ed protocol is in the given list.
  /// Supported values are "http", "tls", "fakedns".
  public var destinationOverride: [String] = []

  public var domainsExcluded: [String] = []

  /// Whether should only try to sniff metadata without waiting for client input.
  /// Can be used to support SMTP like protocol where server send the first
  /// message.
  public var metadataOnly: Bool = false

  public var routeOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Proxyman_ReceiverConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PortList specifies the ports which the Receiver should listen on.
  public var portList: Xray_Common_Net_PortList {
    get {return _portList ?? Xray_Common_Net_PortList()}
    set {_portList = newValue}
  }
  /// Returns true if `portList` has been explicitly set.
  public var hasPortList: Bool {return self._portList != nil}
  /// Clears the value of `portList`. Subsequent reads from it will return its default value.
  public mutating func clearPortList() {self._portList = nil}

  /// Listen specifies the IP address that the Receiver should listen on.
  public var listen: Xray_Common_Net_IPOrDomain {
    get {return _listen ?? Xray_Common_Net_IPOrDomain()}
    set {_listen = newValue}
  }
  /// Returns true if `listen` has been explicitly set.
  public var hasListen: Bool {return self._listen != nil}
  /// Clears the value of `listen`. Subsequent reads from it will return its default value.
  public mutating func clearListen() {self._listen = nil}

  public var streamSettings: Xray_Transport_Internet_StreamConfig {
    get {return _streamSettings ?? Xray_Transport_Internet_StreamConfig()}
    set {_streamSettings = newValue}
  }
  /// Returns true if `streamSettings` has been explicitly set.
  public var hasStreamSettings: Bool {return self._streamSettings != nil}
  /// Clears the value of `streamSettings`. Subsequent reads from it will return its default value.
  public mutating func clearStreamSettings() {self._streamSettings = nil}

  public var receiveOriginalDestination: Bool = false

  public var sniffingSettings: Xray_App_Proxyman_SniffingConfig {
    get {return _sniffingSettings ?? Xray_App_Proxyman_SniffingConfig()}
    set {_sniffingSettings = newValue}
  }
  /// Returns true if `sniffingSettings` has been explicitly set.
  public var hasSniffingSettings: Bool {return self._sniffingSettings != nil}
  /// Clears the value of `sniffingSettings`. Subsequent reads from it will return its default value.
  public mutating func clearSniffingSettings() {self._sniffingSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _portList: Xray_Common_Net_PortList? = nil
  fileprivate var _listen: Xray_Common_Net_IPOrDomain? = nil
  fileprivate var _streamSettings: Xray_Transport_Internet_StreamConfig? = nil
  fileprivate var _sniffingSettings: Xray_App_Proxyman_SniffingConfig? = nil
}

public struct Xray_App_Proxyman_InboundHandlerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tag: String = String()

  public var receiverSettings: Xray_Common_Serial_TypedMessage {
    get {return _receiverSettings ?? Xray_Common_Serial_TypedMessage()}
    set {_receiverSettings = newValue}
  }
  /// Returns true if `receiverSettings` has been explicitly set.
  public var hasReceiverSettings: Bool {return self._receiverSettings != nil}
  /// Clears the value of `receiverSettings`. Subsequent reads from it will return its default value.
  public mutating func clearReceiverSettings() {self._receiverSettings = nil}

  public var proxySettings: Xray_Common_Serial_TypedMessage {
    get {return _proxySettings ?? Xray_Common_Serial_TypedMessage()}
    set {_proxySettings = newValue}
  }
  /// Returns true if `proxySettings` has been explicitly set.
  public var hasProxySettings: Bool {return self._proxySettings != nil}
  /// Clears the value of `proxySettings`. Subsequent reads from it will return its default value.
  public mutating func clearProxySettings() {self._proxySettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _receiverSettings: Xray_Common_Serial_TypedMessage? = nil
  fileprivate var _proxySettings: Xray_Common_Serial_TypedMessage? = nil
}

public struct Xray_App_Proxyman_OutboundConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Proxyman_SenderConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Send traffic through the given IP. Only IP is allowed.
  public var via: Xray_Common_Net_IPOrDomain {
    get {return _via ?? Xray_Common_Net_IPOrDomain()}
    set {_via = newValue}
  }
  /// Returns true if `via` has been explicitly set.
  public var hasVia: Bool {return self._via != nil}
  /// Clears the value of `via`. Subsequent reads from it will return its default value.
  public mutating func clearVia() {self._via = nil}

  public var streamSettings: Xray_Transport_Internet_StreamConfig {
    get {return _streamSettings ?? Xray_Transport_Internet_StreamConfig()}
    set {_streamSettings = newValue}
  }
  /// Returns true if `streamSettings` has been explicitly set.
  public var hasStreamSettings: Bool {return self._streamSettings != nil}
  /// Clears the value of `streamSettings`. Subsequent reads from it will return its default value.
  public mutating func clearStreamSettings() {self._streamSettings = nil}

  public var proxySettings: Xray_Transport_Internet_ProxyConfig {
    get {return _proxySettings ?? Xray_Transport_Internet_ProxyConfig()}
    set {_proxySettings = newValue}
  }
  /// Returns true if `proxySettings` has been explicitly set.
  public var hasProxySettings: Bool {return self._proxySettings != nil}
  /// Clears the value of `proxySettings`. Subsequent reads from it will return its default value.
  public mutating func clearProxySettings() {self._proxySettings = nil}

  public var multiplexSettings: Xray_App_Proxyman_MultiplexingConfig {
    get {return _multiplexSettings ?? Xray_App_Proxyman_MultiplexingConfig()}
    set {_multiplexSettings = newValue}
  }
  /// Returns true if `multiplexSettings` has been explicitly set.
  public var hasMultiplexSettings: Bool {return self._multiplexSettings != nil}
  /// Clears the value of `multiplexSettings`. Subsequent reads from it will return its default value.
  public mutating func clearMultiplexSettings() {self._multiplexSettings = nil}

  public var viaCidr: String = String()

  public var targetStrategy: Xray_Transport_Internet_DomainStrategy = .asIs

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _via: Xray_Common_Net_IPOrDomain? = nil
  fileprivate var _streamSettings: Xray_Transport_Internet_StreamConfig? = nil
  fileprivate var _proxySettings: Xray_Transport_Internet_ProxyConfig? = nil
  fileprivate var _multiplexSettings: Xray_App_Proxyman_MultiplexingConfig? = nil
}

public struct Xray_App_Proxyman_MultiplexingConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not Mux is enabled.
  public var enabled: Bool = false

  /// Max number of concurrent connections that one Mux connection can handle.
  public var concurrency: Int32 = 0

  /// Transport XUDP in another Mux.
  public var xudpConcurrency: Int32 = 0

  /// "reject" (default), "allow" or "skip".
  public var xudpProxyUdp443: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.app.proxyman"

extension Xray_App_Proxyman_InboundConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InboundConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Proxyman_InboundConfig, rhs: Xray_App_Proxyman_InboundConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Proxyman_SniffingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SniffingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "destination_override"),
    3: .standard(proto: "domains_excluded"),
    4: .standard(proto: "metadata_only"),
    5: .standard(proto: "route_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.destinationOverride) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.domainsExcluded) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.metadataOnly) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.routeOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.destinationOverride.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destinationOverride, fieldNumber: 2)
    }
    if !self.domainsExcluded.isEmpty {
      try visitor.visitRepeatedStringField(value: self.domainsExcluded, fieldNumber: 3)
    }
    if self.metadataOnly != false {
      try visitor.visitSingularBoolField(value: self.metadataOnly, fieldNumber: 4)
    }
    if self.routeOnly != false {
      try visitor.visitSingularBoolField(value: self.routeOnly, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Proxyman_SniffingConfig, rhs: Xray_App_Proxyman_SniffingConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.destinationOverride != rhs.destinationOverride {return false}
    if lhs.domainsExcluded != rhs.domainsExcluded {return false}
    if lhs.metadataOnly != rhs.metadataOnly {return false}
    if lhs.routeOnly != rhs.routeOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Proxyman_ReceiverConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiverConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "port_list"),
    2: .same(proto: "listen"),
    3: .standard(proto: "stream_settings"),
    4: .standard(proto: "receive_original_destination"),
    6: .standard(proto: "sniffing_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._portList) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._listen) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._streamSettings) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.receiveOriginalDestination) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sniffingSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._portList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._listen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._streamSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.receiveOriginalDestination != false {
      try visitor.visitSingularBoolField(value: self.receiveOriginalDestination, fieldNumber: 4)
    }
    try { if let v = self._sniffingSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Proxyman_ReceiverConfig, rhs: Xray_App_Proxyman_ReceiverConfig) -> Bool {
    if lhs._portList != rhs._portList {return false}
    if lhs._listen != rhs._listen {return false}
    if lhs._streamSettings != rhs._streamSettings {return false}
    if lhs.receiveOriginalDestination != rhs.receiveOriginalDestination {return false}
    if lhs._sniffingSettings != rhs._sniffingSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Proxyman_InboundHandlerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InboundHandlerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .standard(proto: "receiver_settings"),
    3: .standard(proto: "proxy_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiverSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._proxySettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    try { if let v = self._receiverSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._proxySettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Proxyman_InboundHandlerConfig, rhs: Xray_App_Proxyman_InboundHandlerConfig) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs._receiverSettings != rhs._receiverSettings {return false}
    if lhs._proxySettings != rhs._proxySettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Proxyman_OutboundConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutboundConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Proxyman_OutboundConfig, rhs: Xray_App_Proxyman_OutboundConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Proxyman_SenderConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SenderConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "via"),
    2: .standard(proto: "stream_settings"),
    3: .standard(proto: "proxy_settings"),
    4: .standard(proto: "multiplex_settings"),
    5: .standard(proto: "via_cidr"),
    6: .standard(proto: "target_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._via) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._streamSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._proxySettings) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._multiplexSettings) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.viaCidr) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.targetStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._via {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._streamSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._proxySettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._multiplexSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.viaCidr.isEmpty {
      try visitor.visitSingularStringField(value: self.viaCidr, fieldNumber: 5)
    }
    if self.targetStrategy != .asIs {
      try visitor.visitSingularEnumField(value: self.targetStrategy, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Proxyman_SenderConfig, rhs: Xray_App_Proxyman_SenderConfig) -> Bool {
    if lhs._via != rhs._via {return false}
    if lhs._streamSettings != rhs._streamSettings {return false}
    if lhs._proxySettings != rhs._proxySettings {return false}
    if lhs._multiplexSettings != rhs._multiplexSettings {return false}
    if lhs.viaCidr != rhs.viaCidr {return false}
    if lhs.targetStrategy != rhs.targetStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Proxyman_MultiplexingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiplexingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "concurrency"),
    3: .same(proto: "xudpConcurrency"),
    4: .same(proto: "xudpProxyUDP443"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.concurrency) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.xudpConcurrency) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.xudpProxyUdp443) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.concurrency != 0 {
      try visitor.visitSingularInt32Field(value: self.concurrency, fieldNumber: 2)
    }
    if self.xudpConcurrency != 0 {
      try visitor.visitSingularInt32Field(value: self.xudpConcurrency, fieldNumber: 3)
    }
    if !self.xudpProxyUdp443.isEmpty {
      try visitor.visitSingularStringField(value: self.xudpProxyUdp443, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Proxyman_MultiplexingConfig, rhs: Xray_App_Proxyman_MultiplexingConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.concurrency != rhs.concurrency {return false}
    if lhs.xudpConcurrency != rhs.xudpConcurrency {return false}
    if lhs.xudpProxyUdp443 != rhs.xudpProxyUdp443 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
