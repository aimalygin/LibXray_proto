// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transport/internet/splithttp/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_Transport_Internet_Splithttp_RangeConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: Int32 = 0

  public var to: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Transport_Internet_Splithttp_XmuxConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxConcurrency: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _maxConcurrency ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_maxConcurrency = newValue}
  }
  /// Returns true if `maxConcurrency` has been explicitly set.
  public var hasMaxConcurrency: Bool {return self._maxConcurrency != nil}
  /// Clears the value of `maxConcurrency`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConcurrency() {self._maxConcurrency = nil}

  public var maxConnections: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _maxConnections ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_maxConnections = newValue}
  }
  /// Returns true if `maxConnections` has been explicitly set.
  public var hasMaxConnections: Bool {return self._maxConnections != nil}
  /// Clears the value of `maxConnections`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConnections() {self._maxConnections = nil}

  public var cMaxReuseTimes: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _cMaxReuseTimes ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_cMaxReuseTimes = newValue}
  }
  /// Returns true if `cMaxReuseTimes` has been explicitly set.
  public var hasCMaxReuseTimes: Bool {return self._cMaxReuseTimes != nil}
  /// Clears the value of `cMaxReuseTimes`. Subsequent reads from it will return its default value.
  public mutating func clearCMaxReuseTimes() {self._cMaxReuseTimes = nil}

  public var cMaxLifetimeMs: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _cMaxLifetimeMs ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_cMaxLifetimeMs = newValue}
  }
  /// Returns true if `cMaxLifetimeMs` has been explicitly set.
  public var hasCMaxLifetimeMs: Bool {return self._cMaxLifetimeMs != nil}
  /// Clears the value of `cMaxLifetimeMs`. Subsequent reads from it will return its default value.
  public mutating func clearCMaxLifetimeMs() {self._cMaxLifetimeMs = nil}

  public var hMaxRequestTimes: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _hMaxRequestTimes ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_hMaxRequestTimes = newValue}
  }
  /// Returns true if `hMaxRequestTimes` has been explicitly set.
  public var hasHMaxRequestTimes: Bool {return self._hMaxRequestTimes != nil}
  /// Clears the value of `hMaxRequestTimes`. Subsequent reads from it will return its default value.
  public mutating func clearHMaxRequestTimes() {self._hMaxRequestTimes = nil}

  public var hKeepAlivePeriod: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxConcurrency: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
  fileprivate var _maxConnections: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
  fileprivate var _cMaxReuseTimes: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
  fileprivate var _cMaxLifetimeMs: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
  fileprivate var _hMaxRequestTimes: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
}

public struct Xray_Transport_Internet_Splithttp_Config: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String {
    get {return _storage._host}
    set {_uniqueStorage()._host = newValue}
  }

  public var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  public var mode: String {
    get {return _storage._mode}
    set {_uniqueStorage()._mode = newValue}
  }

  public var headers: Dictionary<String,String> {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  public var xPaddingBytes: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _storage._xPaddingBytes ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_uniqueStorage()._xPaddingBytes = newValue}
  }
  /// Returns true if `xPaddingBytes` has been explicitly set.
  public var hasXPaddingBytes: Bool {return _storage._xPaddingBytes != nil}
  /// Clears the value of `xPaddingBytes`. Subsequent reads from it will return its default value.
  public mutating func clearXPaddingBytes() {_uniqueStorage()._xPaddingBytes = nil}

  public var noGrpcheader: Bool {
    get {return _storage._noGrpcheader}
    set {_uniqueStorage()._noGrpcheader = newValue}
  }

  public var noSseheader: Bool {
    get {return _storage._noSseheader}
    set {_uniqueStorage()._noSseheader = newValue}
  }

  public var scMaxEachPostBytes: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _storage._scMaxEachPostBytes ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_uniqueStorage()._scMaxEachPostBytes = newValue}
  }
  /// Returns true if `scMaxEachPostBytes` has been explicitly set.
  public var hasScMaxEachPostBytes: Bool {return _storage._scMaxEachPostBytes != nil}
  /// Clears the value of `scMaxEachPostBytes`. Subsequent reads from it will return its default value.
  public mutating func clearScMaxEachPostBytes() {_uniqueStorage()._scMaxEachPostBytes = nil}

  public var scMinPostsIntervalMs: Xray_Transport_Internet_Splithttp_RangeConfig {
    get {return _storage._scMinPostsIntervalMs ?? Xray_Transport_Internet_Splithttp_RangeConfig()}
    set {_uniqueStorage()._scMinPostsIntervalMs = newValue}
  }
  /// Returns true if `scMinPostsIntervalMs` has been explicitly set.
  public var hasScMinPostsIntervalMs: Bool {return _storage._scMinPostsIntervalMs != nil}
  /// Clears the value of `scMinPostsIntervalMs`. Subsequent reads from it will return its default value.
  public mutating func clearScMinPostsIntervalMs() {_uniqueStorage()._scMinPostsIntervalMs = nil}

  public var scMaxBufferedPosts: Int64 {
    get {return _storage._scMaxBufferedPosts}
    set {_uniqueStorage()._scMaxBufferedPosts = newValue}
  }

  public var xmux: Xray_Transport_Internet_Splithttp_XmuxConfig {
    get {return _storage._xmux ?? Xray_Transport_Internet_Splithttp_XmuxConfig()}
    set {_uniqueStorage()._xmux = newValue}
  }
  /// Returns true if `xmux` has been explicitly set.
  public var hasXmux: Bool {return _storage._xmux != nil}
  /// Clears the value of `xmux`. Subsequent reads from it will return its default value.
  public mutating func clearXmux() {_uniqueStorage()._xmux = nil}

  public var downloadSettings: Xray_Transport_Internet_StreamConfig {
    get {return _storage._downloadSettings ?? Xray_Transport_Internet_StreamConfig()}
    set {_uniqueStorage()._downloadSettings = newValue}
  }
  /// Returns true if `downloadSettings` has been explicitly set.
  public var hasDownloadSettings: Bool {return _storage._downloadSettings != nil}
  /// Clears the value of `downloadSettings`. Subsequent reads from it will return its default value.
  public mutating func clearDownloadSettings() {_uniqueStorage()._downloadSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.transport.internet.splithttp"

extension Xray_Transport_Internet_Splithttp_RangeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.from) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.from != 0 {
      try visitor.visitSingularInt32Field(value: self.from, fieldNumber: 1)
    }
    if self.to != 0 {
      try visitor.visitSingularInt32Field(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Splithttp_RangeConfig, rhs: Xray_Transport_Internet_Splithttp_RangeConfig) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Splithttp_XmuxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".XmuxConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxConcurrency"),
    2: .same(proto: "maxConnections"),
    3: .same(proto: "cMaxReuseTimes"),
    4: .same(proto: "cMaxLifetimeMs"),
    5: .same(proto: "hMaxRequestTimes"),
    6: .same(proto: "hKeepAlivePeriod"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._maxConcurrency) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxConnections) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cMaxReuseTimes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cMaxLifetimeMs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._hMaxRequestTimes) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.hKeepAlivePeriod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxConcurrency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxConnections {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cMaxReuseTimes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cMaxLifetimeMs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._hMaxRequestTimes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.hKeepAlivePeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.hKeepAlivePeriod, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Splithttp_XmuxConfig, rhs: Xray_Transport_Internet_Splithttp_XmuxConfig) -> Bool {
    if lhs._maxConcurrency != rhs._maxConcurrency {return false}
    if lhs._maxConnections != rhs._maxConnections {return false}
    if lhs._cMaxReuseTimes != rhs._cMaxReuseTimes {return false}
    if lhs._cMaxLifetimeMs != rhs._cMaxLifetimeMs {return false}
    if lhs._hMaxRequestTimes != rhs._hMaxRequestTimes {return false}
    if lhs.hKeepAlivePeriod != rhs.hKeepAlivePeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Splithttp_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "path"),
    3: .same(proto: "mode"),
    4: .same(proto: "headers"),
    5: .same(proto: "xPaddingBytes"),
    6: .same(proto: "noGRPCHeader"),
    7: .same(proto: "noSSEHeader"),
    8: .same(proto: "scMaxEachPostBytes"),
    9: .same(proto: "scMinPostsIntervalMs"),
    10: .same(proto: "scMaxBufferedPosts"),
    11: .same(proto: "xmux"),
    12: .same(proto: "downloadSettings"),
  ]

  fileprivate class _StorageClass {
    var _host: String = String()
    var _path: String = String()
    var _mode: String = String()
    var _headers: Dictionary<String,String> = [:]
    var _xPaddingBytes: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
    var _noGrpcheader: Bool = false
    var _noSseheader: Bool = false
    var _scMaxEachPostBytes: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
    var _scMinPostsIntervalMs: Xray_Transport_Internet_Splithttp_RangeConfig? = nil
    var _scMaxBufferedPosts: Int64 = 0
    var _xmux: Xray_Transport_Internet_Splithttp_XmuxConfig? = nil
    var _downloadSettings: Xray_Transport_Internet_StreamConfig? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _host = source._host
      _path = source._path
      _mode = source._mode
      _headers = source._headers
      _xPaddingBytes = source._xPaddingBytes
      _noGrpcheader = source._noGrpcheader
      _noSseheader = source._noSseheader
      _scMaxEachPostBytes = source._scMaxEachPostBytes
      _scMinPostsIntervalMs = source._scMinPostsIntervalMs
      _scMaxBufferedPosts = source._scMaxBufferedPosts
      _xmux = source._xmux
      _downloadSettings = source._downloadSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._host) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._mode) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._headers) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._xPaddingBytes) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._noGrpcheader) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._noSseheader) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scMaxEachPostBytes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scMinPostsIntervalMs) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._scMaxBufferedPosts) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._xmux) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._downloadSettings) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 1)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 2)
      }
      if !_storage._mode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mode, fieldNumber: 3)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._headers, fieldNumber: 4)
      }
      try { if let v = _storage._xPaddingBytes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._noGrpcheader != false {
        try visitor.visitSingularBoolField(value: _storage._noGrpcheader, fieldNumber: 6)
      }
      if _storage._noSseheader != false {
        try visitor.visitSingularBoolField(value: _storage._noSseheader, fieldNumber: 7)
      }
      try { if let v = _storage._scMaxEachPostBytes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._scMinPostsIntervalMs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._scMaxBufferedPosts != 0 {
        try visitor.visitSingularInt64Field(value: _storage._scMaxBufferedPosts, fieldNumber: 10)
      }
      try { if let v = _storage._xmux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._downloadSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Splithttp_Config, rhs: Xray_Transport_Internet_Splithttp_Config) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._host != rhs_storage._host {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._xPaddingBytes != rhs_storage._xPaddingBytes {return false}
        if _storage._noGrpcheader != rhs_storage._noGrpcheader {return false}
        if _storage._noSseheader != rhs_storage._noSseheader {return false}
        if _storage._scMaxEachPostBytes != rhs_storage._scMaxEachPostBytes {return false}
        if _storage._scMinPostsIntervalMs != rhs_storage._scMinPostsIntervalMs {return false}
        if _storage._scMaxBufferedPosts != rhs_storage._scMaxBufferedPosts {return false}
        if _storage._xmux != rhs_storage._xmux {return false}
        if _storage._downloadSettings != rhs_storage._downloadSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
