// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transport/internet/kcp/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Maximum Transmission Unit, in bytes.
public struct Xray_Transport_Internet_Kcp_MTU: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transmission Time Interview, in milli-sec.
public struct Xray_Transport_Internet_Kcp_TTI: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Uplink capacity, in MB.
public struct Xray_Transport_Internet_Kcp_UplinkCapacity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Downlink capacity, in MB.
public struct Xray_Transport_Internet_Kcp_DownlinkCapacity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Transport_Internet_Kcp_WriteBuffer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Buffer size in bytes.
  public var size: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Transport_Internet_Kcp_ReadBuffer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Buffer size in bytes.
  public var size: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Transport_Internet_Kcp_ConnectionReuse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Pre-shared secret between client and server. It is used for traffic obfuscation.
/// Note that if seed is absent in the config, the traffic will still be obfuscated,
/// but by a predefined algorithm.
public struct Xray_Transport_Internet_Kcp_EncryptionSeed: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seed: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Transport_Internet_Kcp_Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mtu: Xray_Transport_Internet_Kcp_MTU {
    get {return _mtu ?? Xray_Transport_Internet_Kcp_MTU()}
    set {_mtu = newValue}
  }
  /// Returns true if `mtu` has been explicitly set.
  public var hasMtu: Bool {return self._mtu != nil}
  /// Clears the value of `mtu`. Subsequent reads from it will return its default value.
  public mutating func clearMtu() {self._mtu = nil}

  public var tti: Xray_Transport_Internet_Kcp_TTI {
    get {return _tti ?? Xray_Transport_Internet_Kcp_TTI()}
    set {_tti = newValue}
  }
  /// Returns true if `tti` has been explicitly set.
  public var hasTti: Bool {return self._tti != nil}
  /// Clears the value of `tti`. Subsequent reads from it will return its default value.
  public mutating func clearTti() {self._tti = nil}

  public var uplinkCapacity: Xray_Transport_Internet_Kcp_UplinkCapacity {
    get {return _uplinkCapacity ?? Xray_Transport_Internet_Kcp_UplinkCapacity()}
    set {_uplinkCapacity = newValue}
  }
  /// Returns true if `uplinkCapacity` has been explicitly set.
  public var hasUplinkCapacity: Bool {return self._uplinkCapacity != nil}
  /// Clears the value of `uplinkCapacity`. Subsequent reads from it will return its default value.
  public mutating func clearUplinkCapacity() {self._uplinkCapacity = nil}

  public var downlinkCapacity: Xray_Transport_Internet_Kcp_DownlinkCapacity {
    get {return _downlinkCapacity ?? Xray_Transport_Internet_Kcp_DownlinkCapacity()}
    set {_downlinkCapacity = newValue}
  }
  /// Returns true if `downlinkCapacity` has been explicitly set.
  public var hasDownlinkCapacity: Bool {return self._downlinkCapacity != nil}
  /// Clears the value of `downlinkCapacity`. Subsequent reads from it will return its default value.
  public mutating func clearDownlinkCapacity() {self._downlinkCapacity = nil}

  public var congestion: Bool = false

  public var writeBuffer: Xray_Transport_Internet_Kcp_WriteBuffer {
    get {return _writeBuffer ?? Xray_Transport_Internet_Kcp_WriteBuffer()}
    set {_writeBuffer = newValue}
  }
  /// Returns true if `writeBuffer` has been explicitly set.
  public var hasWriteBuffer: Bool {return self._writeBuffer != nil}
  /// Clears the value of `writeBuffer`. Subsequent reads from it will return its default value.
  public mutating func clearWriteBuffer() {self._writeBuffer = nil}

  public var readBuffer: Xray_Transport_Internet_Kcp_ReadBuffer {
    get {return _readBuffer ?? Xray_Transport_Internet_Kcp_ReadBuffer()}
    set {_readBuffer = newValue}
  }
  /// Returns true if `readBuffer` has been explicitly set.
  public var hasReadBuffer: Bool {return self._readBuffer != nil}
  /// Clears the value of `readBuffer`. Subsequent reads from it will return its default value.
  public mutating func clearReadBuffer() {self._readBuffer = nil}

  public var headerConfig: Xray_Common_Serial_TypedMessage {
    get {return _headerConfig ?? Xray_Common_Serial_TypedMessage()}
    set {_headerConfig = newValue}
  }
  /// Returns true if `headerConfig` has been explicitly set.
  public var hasHeaderConfig: Bool {return self._headerConfig != nil}
  /// Clears the value of `headerConfig`. Subsequent reads from it will return its default value.
  public mutating func clearHeaderConfig() {self._headerConfig = nil}

  public var seed: Xray_Transport_Internet_Kcp_EncryptionSeed {
    get {return _seed ?? Xray_Transport_Internet_Kcp_EncryptionSeed()}
    set {_seed = newValue}
  }
  /// Returns true if `seed` has been explicitly set.
  public var hasSeed: Bool {return self._seed != nil}
  /// Clears the value of `seed`. Subsequent reads from it will return its default value.
  public mutating func clearSeed() {self._seed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mtu: Xray_Transport_Internet_Kcp_MTU? = nil
  fileprivate var _tti: Xray_Transport_Internet_Kcp_TTI? = nil
  fileprivate var _uplinkCapacity: Xray_Transport_Internet_Kcp_UplinkCapacity? = nil
  fileprivate var _downlinkCapacity: Xray_Transport_Internet_Kcp_DownlinkCapacity? = nil
  fileprivate var _writeBuffer: Xray_Transport_Internet_Kcp_WriteBuffer? = nil
  fileprivate var _readBuffer: Xray_Transport_Internet_Kcp_ReadBuffer? = nil
  fileprivate var _headerConfig: Xray_Common_Serial_TypedMessage? = nil
  fileprivate var _seed: Xray_Transport_Internet_Kcp_EncryptionSeed? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.transport.internet.kcp"

extension Xray_Transport_Internet_Kcp_MTU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MTU"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_MTU, rhs: Xray_Transport_Internet_Kcp_MTU) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_TTI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TTI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_TTI, rhs: Xray_Transport_Internet_Kcp_TTI) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_UplinkCapacity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UplinkCapacity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_UplinkCapacity, rhs: Xray_Transport_Internet_Kcp_UplinkCapacity) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_DownlinkCapacity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownlinkCapacity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_DownlinkCapacity, rhs: Xray_Transport_Internet_Kcp_DownlinkCapacity) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_WriteBuffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteBuffer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_WriteBuffer, rhs: Xray_Transport_Internet_Kcp_WriteBuffer) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_ReadBuffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadBuffer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_ReadBuffer, rhs: Xray_Transport_Internet_Kcp_ReadBuffer) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_ConnectionReuse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionReuse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_ConnectionReuse, rhs: Xray_Transport_Internet_Kcp_ConnectionReuse) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_EncryptionSeed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptionSeed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.seed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.seed.isEmpty {
      try visitor.visitSingularStringField(value: self.seed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_EncryptionSeed, rhs: Xray_Transport_Internet_Kcp_EncryptionSeed) -> Bool {
    if lhs.seed != rhs.seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Transport_Internet_Kcp_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mtu"),
    2: .same(proto: "tti"),
    3: .standard(proto: "uplink_capacity"),
    4: .standard(proto: "downlink_capacity"),
    5: .same(proto: "congestion"),
    6: .standard(proto: "write_buffer"),
    7: .standard(proto: "read_buffer"),
    8: .standard(proto: "header_config"),
    10: .same(proto: "seed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mtu) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tti) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._uplinkCapacity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._downlinkCapacity) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.congestion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._writeBuffer) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._readBuffer) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._headerConfig) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._seed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mtu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tti {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uplinkCapacity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._downlinkCapacity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.congestion != false {
      try visitor.visitSingularBoolField(value: self.congestion, fieldNumber: 5)
    }
    try { if let v = self._writeBuffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._readBuffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._headerConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._seed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Transport_Internet_Kcp_Config, rhs: Xray_Transport_Internet_Kcp_Config) -> Bool {
    if lhs._mtu != rhs._mtu {return false}
    if lhs._tti != rhs._tti {return false}
    if lhs._uplinkCapacity != rhs._uplinkCapacity {return false}
    if lhs._downlinkCapacity != rhs._downlinkCapacity {return false}
    if lhs.congestion != rhs.congestion {return false}
    if lhs._writeBuffer != rhs._writeBuffer {return false}
    if lhs._readBuffer != rhs._readBuffer {return false}
    if lhs._headerConfig != rhs._headerConfig {return false}
    if lhs._seed != rhs._seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
