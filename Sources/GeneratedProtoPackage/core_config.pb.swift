// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Config is the master config of Xray. Xray takes this config as input and
/// functions accordingly.
public struct Xray_Core_Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Inbound handler configurations. Must have at least one item.
  public var inbound: [Xray_Core_InboundHandlerConfig] = []

  /// Outbound handler configurations. Must have at least one item. The first
  /// item is used as default for routing.
  public var outbound: [Xray_Core_OutboundHandlerConfig] = []

  /// App is for configurations of all features in Xray. A feature must
  /// implement the Feature interface, and its config type must be registered
  /// through common.RegisterConfig.
  public var app: [Xray_Common_Serial_TypedMessage] = []

  /// Configuration for extensions. The config may not work if corresponding
  /// extension is not loaded into Xray. Xray will ignore such config during
  /// initialization.
  public var `extension`: [Xray_Common_Serial_TypedMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// InboundHandlerConfig is the configuration for inbound handler.
public struct Xray_Core_InboundHandlerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tag of the inbound handler. The tag must be unique among all inbound
  /// handlers
  public var tag: String = String()

  /// Settings for how this inbound proxy is handled.
  public var receiverSettings: Xray_Common_Serial_TypedMessage {
    get {return _receiverSettings ?? Xray_Common_Serial_TypedMessage()}
    set {_receiverSettings = newValue}
  }
  /// Returns true if `receiverSettings` has been explicitly set.
  public var hasReceiverSettings: Bool {return self._receiverSettings != nil}
  /// Clears the value of `receiverSettings`. Subsequent reads from it will return its default value.
  public mutating func clearReceiverSettings() {self._receiverSettings = nil}

  /// Settings for inbound proxy. Must be one of the inbound proxies.
  public var proxySettings: Xray_Common_Serial_TypedMessage {
    get {return _proxySettings ?? Xray_Common_Serial_TypedMessage()}
    set {_proxySettings = newValue}
  }
  /// Returns true if `proxySettings` has been explicitly set.
  public var hasProxySettings: Bool {return self._proxySettings != nil}
  /// Clears the value of `proxySettings`. Subsequent reads from it will return its default value.
  public mutating func clearProxySettings() {self._proxySettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _receiverSettings: Xray_Common_Serial_TypedMessage? = nil
  fileprivate var _proxySettings: Xray_Common_Serial_TypedMessage? = nil
}

/// OutboundHandlerConfig is the configuration for outbound handler.
public struct Xray_Core_OutboundHandlerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tag of this outbound handler.
  public var tag: String = String()

  /// Settings for how to dial connection for this outbound handler.
  public var senderSettings: Xray_Common_Serial_TypedMessage {
    get {return _senderSettings ?? Xray_Common_Serial_TypedMessage()}
    set {_senderSettings = newValue}
  }
  /// Returns true if `senderSettings` has been explicitly set.
  public var hasSenderSettings: Bool {return self._senderSettings != nil}
  /// Clears the value of `senderSettings`. Subsequent reads from it will return its default value.
  public mutating func clearSenderSettings() {self._senderSettings = nil}

  /// Settings for this outbound proxy. Must be one of the outbound proxies.
  public var proxySettings: Xray_Common_Serial_TypedMessage {
    get {return _proxySettings ?? Xray_Common_Serial_TypedMessage()}
    set {_proxySettings = newValue}
  }
  /// Returns true if `proxySettings` has been explicitly set.
  public var hasProxySettings: Bool {return self._proxySettings != nil}
  /// Clears the value of `proxySettings`. Subsequent reads from it will return its default value.
  public mutating func clearProxySettings() {self._proxySettings = nil}

  /// If not zero, this outbound will be expired in seconds. Not used for now.
  public var expire: Int64 = 0

  /// Comment of this outbound handler. Not used for now.
  public var comment: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _senderSettings: Xray_Common_Serial_TypedMessage? = nil
  fileprivate var _proxySettings: Xray_Common_Serial_TypedMessage? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.core"

extension Xray_Core_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inbound"),
    2: .same(proto: "outbound"),
    4: .same(proto: "app"),
    6: .same(proto: "extension"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inbound) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outbound) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.app) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.`extension`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inbound.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inbound, fieldNumber: 1)
    }
    if !self.outbound.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outbound, fieldNumber: 2)
    }
    if !self.app.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.app, fieldNumber: 4)
    }
    if !self.`extension`.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.`extension`, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_Config, rhs: Xray_Core_Config) -> Bool {
    if lhs.inbound != rhs.inbound {return false}
    if lhs.outbound != rhs.outbound {return false}
    if lhs.app != rhs.app {return false}
    if lhs.`extension` != rhs.`extension` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Core_InboundHandlerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InboundHandlerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .standard(proto: "receiver_settings"),
    3: .standard(proto: "proxy_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiverSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._proxySettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    try { if let v = self._receiverSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._proxySettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_InboundHandlerConfig, rhs: Xray_Core_InboundHandlerConfig) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs._receiverSettings != rhs._receiverSettings {return false}
    if lhs._proxySettings != rhs._proxySettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Core_OutboundHandlerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutboundHandlerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .standard(proto: "sender_settings"),
    3: .standard(proto: "proxy_settings"),
    4: .same(proto: "expire"),
    5: .same(proto: "comment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._senderSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._proxySettings) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expire) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    try { if let v = self._senderSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._proxySettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.expire != 0 {
      try visitor.visitSingularInt64Field(value: self.expire, fieldNumber: 4)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_OutboundHandlerConfig, rhs: Xray_Core_OutboundHandlerConfig) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs._senderSettings != rhs._senderSettings {return false}
    if lhs._proxySettings != rhs._proxySettings {return false}
    if lhs.expire != rhs.expire {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
