// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proxy/wireguard/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_Proxy_Wireguard_PeerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: String = String()

  public var preSharedKey: String = String()

  public var endpoint: String = String()

  public var keepAlive: UInt32 = 0

  public var allowedIps: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Proxy_Wireguard_DeviceConfig: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var secretKey: String = String()

  public var endpoint: [String] = []

  public var peers: [Xray_Proxy_Wireguard_PeerConfig] = []

  public var mtu: Int32 = 0

  public var numWorkers: Int32 = 0

  public var reserved: Data = Data()

  public var domainStrategy: Xray_Proxy_Wireguard_DeviceConfig.DomainStrategy = .forceIp

  public var isClient: Bool = false

  public var noKernelTun: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DomainStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case forceIp // = 0
    case forceIp4 // = 1
    case forceIp6 // = 2
    case forceIp46 // = 3
    case forceIp64 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .forceIp
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .forceIp
      case 1: self = .forceIp4
      case 2: self = .forceIp6
      case 3: self = .forceIp46
      case 4: self = .forceIp64
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .forceIp: return 0
      case .forceIp4: return 1
      case .forceIp6: return 2
      case .forceIp46: return 3
      case .forceIp64: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Xray_Proxy_Wireguard_DeviceConfig.DomainStrategy] = [
      .forceIp,
      .forceIp4,
      .forceIp6,
      .forceIp46,
      .forceIp64,
    ]

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.proxy.wireguard"

extension Xray_Proxy_Wireguard_PeerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "pre_shared_key"),
    3: .same(proto: "endpoint"),
    4: .standard(proto: "keep_alive"),
    5: .standard(proto: "allowed_ips"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.preSharedKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.keepAlive) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.allowedIps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.preSharedKey.isEmpty {
      try visitor.visitSingularStringField(value: self.preSharedKey, fieldNumber: 2)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 3)
    }
    if self.keepAlive != 0 {
      try visitor.visitSingularUInt32Field(value: self.keepAlive, fieldNumber: 4)
    }
    if !self.allowedIps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedIps, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Proxy_Wireguard_PeerConfig, rhs: Xray_Proxy_Wireguard_PeerConfig) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.preSharedKey != rhs.preSharedKey {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.keepAlive != rhs.keepAlive {return false}
    if lhs.allowedIps != rhs.allowedIps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Proxy_Wireguard_DeviceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "secret_key"),
    2: .same(proto: "endpoint"),
    3: .same(proto: "peers"),
    4: .same(proto: "mtu"),
    5: .standard(proto: "num_workers"),
    6: .same(proto: "reserved"),
    7: .standard(proto: "domain_strategy"),
    8: .standard(proto: "is_client"),
    9: .standard(proto: "no_kernel_tun"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.secretKey) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.mtu) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.numWorkers) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.reserved) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.domainStrategy) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isClient) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.noKernelTun) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.secretKey.isEmpty {
      try visitor.visitSingularStringField(value: self.secretKey, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpoint, fieldNumber: 2)
    }
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 3)
    }
    if self.mtu != 0 {
      try visitor.visitSingularInt32Field(value: self.mtu, fieldNumber: 4)
    }
    if self.numWorkers != 0 {
      try visitor.visitSingularInt32Field(value: self.numWorkers, fieldNumber: 5)
    }
    if !self.reserved.isEmpty {
      try visitor.visitSingularBytesField(value: self.reserved, fieldNumber: 6)
    }
    if self.domainStrategy != .forceIp {
      try visitor.visitSingularEnumField(value: self.domainStrategy, fieldNumber: 7)
    }
    if self.isClient != false {
      try visitor.visitSingularBoolField(value: self.isClient, fieldNumber: 8)
    }
    if self.noKernelTun != false {
      try visitor.visitSingularBoolField(value: self.noKernelTun, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Proxy_Wireguard_DeviceConfig, rhs: Xray_Proxy_Wireguard_DeviceConfig) -> Bool {
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.peers != rhs.peers {return false}
    if lhs.mtu != rhs.mtu {return false}
    if lhs.numWorkers != rhs.numWorkers {return false}
    if lhs.reserved != rhs.reserved {return false}
    if lhs.domainStrategy != rhs.domainStrategy {return false}
    if lhs.isClient != rhs.isClient {return false}
    if lhs.noKernelTun != rhs.noKernelTun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Proxy_Wireguard_DeviceConfig.DomainStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORCE_IP"),
    1: .same(proto: "FORCE_IP4"),
    2: .same(proto: "FORCE_IP6"),
    3: .same(proto: "FORCE_IP46"),
    4: .same(proto: "FORCE_IP64"),
  ]
}
