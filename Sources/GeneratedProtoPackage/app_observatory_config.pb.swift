// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app/observatory/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_Core_App_Observatory_ObservationResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: [Xray_Core_App_Observatory_OutboundStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Core_App_Observatory_HealthPingMeasurementResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var all: Int64 = 0

  public var fail: Int64 = 0

  public var deviation: Int64 = 0

  public var average: Int64 = 0

  public var max: Int64 = 0

  public var min: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Core_App_Observatory_OutboundStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @Document Whether this outbound is usable
  ///@Restriction ReadOnlyForUser
  public var alive: Bool = false

  /// @Document The time for probe request to finish.
  ///@Type time.ms
  ///@Restriction ReadOnlyForUser
  public var delay: Int64 = 0

  /// @Document The last error caused this outbound failed to relay probe request
  ///@Restriction NotMachineReadable
  public var lastErrorReason: String = String()

  /// @Document The outbound tag for this Server
  ///@Type id.outboundTag
  public var outboundTag: String = String()

  /// @Document The time this outbound is known to be alive
  ///@Type id.outboundTag
  public var lastSeenTime: Int64 = 0

  /// @Document The time this outbound is tried
  ///@Type id.outboundTag
  public var lastTryTime: Int64 = 0

  public var healthPing: Xray_Core_App_Observatory_HealthPingMeasurementResult {
    get {return _healthPing ?? Xray_Core_App_Observatory_HealthPingMeasurementResult()}
    set {_healthPing = newValue}
  }
  /// Returns true if `healthPing` has been explicitly set.
  public var hasHealthPing: Bool {return self._healthPing != nil}
  /// Clears the value of `healthPing`. Subsequent reads from it will return its default value.
  public mutating func clearHealthPing() {self._healthPing = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _healthPing: Xray_Core_App_Observatory_HealthPingMeasurementResult? = nil
}

public struct Xray_Core_App_Observatory_ProbeResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @Document Whether this outbound is usable
  ///@Restriction ReadOnlyForUser
  public var alive: Bool = false

  /// @Document The time for probe request to finish.
  ///@Type time.ms
  ///@Restriction ReadOnlyForUser
  public var delay: Int64 = 0

  /// @Document The error caused this outbound failed to relay probe request
  ///@Restriction NotMachineReadable
  public var lastErrorReason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Core_App_Observatory_Intensity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @Document The time interval for a probe request in ms.
  ///@Type time.ms
  public var probeInterval: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_Core_App_Observatory_Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @Document The selectors for outbound under observation
  public var subjectSelector: [String] = []

  public var probeURL: String = String()

  public var probeInterval: Int64 = 0

  public var enableConcurrency: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.core.app.observatory"

extension Xray_Core_App_Observatory_ObservationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObservationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_App_Observatory_ObservationResult, rhs: Xray_Core_App_Observatory_ObservationResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Core_App_Observatory_HealthPingMeasurementResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthPingMeasurementResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "all"),
    2: .same(proto: "fail"),
    3: .same(proto: "deviation"),
    4: .same(proto: "average"),
    5: .same(proto: "max"),
    6: .same(proto: "min"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.all) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fail) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.deviation) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.average) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.max) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.min) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.all != 0 {
      try visitor.visitSingularInt64Field(value: self.all, fieldNumber: 1)
    }
    if self.fail != 0 {
      try visitor.visitSingularInt64Field(value: self.fail, fieldNumber: 2)
    }
    if self.deviation != 0 {
      try visitor.visitSingularInt64Field(value: self.deviation, fieldNumber: 3)
    }
    if self.average != 0 {
      try visitor.visitSingularInt64Field(value: self.average, fieldNumber: 4)
    }
    if self.max != 0 {
      try visitor.visitSingularInt64Field(value: self.max, fieldNumber: 5)
    }
    if self.min != 0 {
      try visitor.visitSingularInt64Field(value: self.min, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_App_Observatory_HealthPingMeasurementResult, rhs: Xray_Core_App_Observatory_HealthPingMeasurementResult) -> Bool {
    if lhs.all != rhs.all {return false}
    if lhs.fail != rhs.fail {return false}
    if lhs.deviation != rhs.deviation {return false}
    if lhs.average != rhs.average {return false}
    if lhs.max != rhs.max {return false}
    if lhs.min != rhs.min {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Core_App_Observatory_OutboundStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutboundStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alive"),
    2: .same(proto: "delay"),
    3: .standard(proto: "last_error_reason"),
    4: .standard(proto: "outbound_tag"),
    5: .standard(proto: "last_seen_time"),
    6: .standard(proto: "last_try_time"),
    7: .standard(proto: "health_ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.alive) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.delay) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastErrorReason) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outboundTag) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.lastSeenTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.lastTryTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._healthPing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.alive != false {
      try visitor.visitSingularBoolField(value: self.alive, fieldNumber: 1)
    }
    if self.delay != 0 {
      try visitor.visitSingularInt64Field(value: self.delay, fieldNumber: 2)
    }
    if !self.lastErrorReason.isEmpty {
      try visitor.visitSingularStringField(value: self.lastErrorReason, fieldNumber: 3)
    }
    if !self.outboundTag.isEmpty {
      try visitor.visitSingularStringField(value: self.outboundTag, fieldNumber: 4)
    }
    if self.lastSeenTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeenTime, fieldNumber: 5)
    }
    if self.lastTryTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastTryTime, fieldNumber: 6)
    }
    try { if let v = self._healthPing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_App_Observatory_OutboundStatus, rhs: Xray_Core_App_Observatory_OutboundStatus) -> Bool {
    if lhs.alive != rhs.alive {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.lastErrorReason != rhs.lastErrorReason {return false}
    if lhs.outboundTag != rhs.outboundTag {return false}
    if lhs.lastSeenTime != rhs.lastSeenTime {return false}
    if lhs.lastTryTime != rhs.lastTryTime {return false}
    if lhs._healthPing != rhs._healthPing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Core_App_Observatory_ProbeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProbeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alive"),
    2: .same(proto: "delay"),
    3: .standard(proto: "last_error_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.alive) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.delay) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastErrorReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alive != false {
      try visitor.visitSingularBoolField(value: self.alive, fieldNumber: 1)
    }
    if self.delay != 0 {
      try visitor.visitSingularInt64Field(value: self.delay, fieldNumber: 2)
    }
    if !self.lastErrorReason.isEmpty {
      try visitor.visitSingularStringField(value: self.lastErrorReason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_App_Observatory_ProbeResult, rhs: Xray_Core_App_Observatory_ProbeResult) -> Bool {
    if lhs.alive != rhs.alive {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.lastErrorReason != rhs.lastErrorReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Core_App_Observatory_Intensity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Intensity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "probe_interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.probeInterval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.probeInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.probeInterval, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_App_Observatory_Intensity, rhs: Xray_Core_App_Observatory_Intensity) -> Bool {
    if lhs.probeInterval != rhs.probeInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_Core_App_Observatory_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "subject_selector"),
    3: .standard(proto: "probe_url"),
    4: .standard(proto: "probe_interval"),
    5: .standard(proto: "enable_concurrency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.subjectSelector) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.probeURL) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.probeInterval) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableConcurrency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subjectSelector.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subjectSelector, fieldNumber: 2)
    }
    if !self.probeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.probeURL, fieldNumber: 3)
    }
    if self.probeInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.probeInterval, fieldNumber: 4)
    }
    if self.enableConcurrency != false {
      try visitor.visitSingularBoolField(value: self.enableConcurrency, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_Core_App_Observatory_Config, rhs: Xray_Core_App_Observatory_Config) -> Bool {
    if lhs.subjectSelector != rhs.subjectSelector {return false}
    if lhs.probeURL != rhs.probeURL {return false}
    if lhs.probeInterval != rhs.probeInterval {return false}
    if lhs.enableConcurrency != rhs.enableConcurrency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
