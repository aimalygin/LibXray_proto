// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app/policy/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Xray_App_Policy_Second: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xray_App_Policy_Policy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeout: Xray_App_Policy_Policy.Timeout {
    get {return _timeout ?? Xray_App_Policy_Policy.Timeout()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  public var stats: Xray_App_Policy_Policy.Stats {
    get {return _stats ?? Xray_App_Policy_Policy.Stats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  public var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  public mutating func clearStats() {self._stats = nil}

  public var buffer: Xray_App_Policy_Policy.Buffer {
    get {return _buffer ?? Xray_App_Policy_Policy.Buffer()}
    set {_buffer = newValue}
  }
  /// Returns true if `buffer` has been explicitly set.
  public var hasBuffer: Bool {return self._buffer != nil}
  /// Clears the value of `buffer`. Subsequent reads from it will return its default value.
  public mutating func clearBuffer() {self._buffer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Timeout is a message for timeout settings in various stages, in seconds.
  public struct Timeout: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var handshake: Xray_App_Policy_Second {
      get {return _handshake ?? Xray_App_Policy_Second()}
      set {_handshake = newValue}
    }
    /// Returns true if `handshake` has been explicitly set.
    public var hasHandshake: Bool {return self._handshake != nil}
    /// Clears the value of `handshake`. Subsequent reads from it will return its default value.
    public mutating func clearHandshake() {self._handshake = nil}

    public var connectionIdle: Xray_App_Policy_Second {
      get {return _connectionIdle ?? Xray_App_Policy_Second()}
      set {_connectionIdle = newValue}
    }
    /// Returns true if `connectionIdle` has been explicitly set.
    public var hasConnectionIdle: Bool {return self._connectionIdle != nil}
    /// Clears the value of `connectionIdle`. Subsequent reads from it will return its default value.
    public mutating func clearConnectionIdle() {self._connectionIdle = nil}

    public var uplinkOnly: Xray_App_Policy_Second {
      get {return _uplinkOnly ?? Xray_App_Policy_Second()}
      set {_uplinkOnly = newValue}
    }
    /// Returns true if `uplinkOnly` has been explicitly set.
    public var hasUplinkOnly: Bool {return self._uplinkOnly != nil}
    /// Clears the value of `uplinkOnly`. Subsequent reads from it will return its default value.
    public mutating func clearUplinkOnly() {self._uplinkOnly = nil}

    public var downlinkOnly: Xray_App_Policy_Second {
      get {return _downlinkOnly ?? Xray_App_Policy_Second()}
      set {_downlinkOnly = newValue}
    }
    /// Returns true if `downlinkOnly` has been explicitly set.
    public var hasDownlinkOnly: Bool {return self._downlinkOnly != nil}
    /// Clears the value of `downlinkOnly`. Subsequent reads from it will return its default value.
    public mutating func clearDownlinkOnly() {self._downlinkOnly = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _handshake: Xray_App_Policy_Second? = nil
    fileprivate var _connectionIdle: Xray_App_Policy_Second? = nil
    fileprivate var _uplinkOnly: Xray_App_Policy_Second? = nil
    fileprivate var _downlinkOnly: Xray_App_Policy_Second? = nil
  }

  public struct Stats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userUplink: Bool = false

    public var userDownlink: Bool = false

    public var userOnline: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Buffer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Buffer size per connection, in bytes. -1 for unlimited buffer.
    public var connection: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _timeout: Xray_App_Policy_Policy.Timeout? = nil
  fileprivate var _stats: Xray_App_Policy_Policy.Stats? = nil
  fileprivate var _buffer: Xray_App_Policy_Policy.Buffer? = nil
}

public struct Xray_App_Policy_SystemPolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stats: Xray_App_Policy_SystemPolicy.Stats {
    get {return _stats ?? Xray_App_Policy_SystemPolicy.Stats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  public var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  public mutating func clearStats() {self._stats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Stats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var inboundUplink: Bool = false

    public var inboundDownlink: Bool = false

    public var outboundUplink: Bool = false

    public var outboundDownlink: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _stats: Xray_App_Policy_SystemPolicy.Stats? = nil
}

public struct Xray_App_Policy_Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var level: Dictionary<UInt32,Xray_App_Policy_Policy> = [:]

  public var system: Xray_App_Policy_SystemPolicy {
    get {return _system ?? Xray_App_Policy_SystemPolicy()}
    set {_system = newValue}
  }
  /// Returns true if `system` has been explicitly set.
  public var hasSystem: Bool {return self._system != nil}
  /// Clears the value of `system`. Subsequent reads from it will return its default value.
  public mutating func clearSystem() {self._system = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _system: Xray_App_Policy_SystemPolicy? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xray.app.policy"

extension Xray_App_Policy_Second: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Second"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_Second, rhs: Xray_App_Policy_Second) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Policy_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
    2: .same(proto: "stats"),
    3: .same(proto: "buffer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._buffer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._buffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_Policy, rhs: Xray_App_Policy_Policy) -> Bool {
    if lhs._timeout != rhs._timeout {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs._buffer != rhs._buffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Policy_Policy.Timeout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xray_App_Policy_Policy.protoMessageName + ".Timeout"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handshake"),
    2: .standard(proto: "connection_idle"),
    3: .standard(proto: "uplink_only"),
    4: .standard(proto: "downlink_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._handshake) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._connectionIdle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._uplinkOnly) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._downlinkOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._handshake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._connectionIdle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uplinkOnly {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._downlinkOnly {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_Policy.Timeout, rhs: Xray_App_Policy_Policy.Timeout) -> Bool {
    if lhs._handshake != rhs._handshake {return false}
    if lhs._connectionIdle != rhs._connectionIdle {return false}
    if lhs._uplinkOnly != rhs._uplinkOnly {return false}
    if lhs._downlinkOnly != rhs._downlinkOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Policy_Policy.Stats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xray_App_Policy_Policy.protoMessageName + ".Stats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_uplink"),
    2: .standard(proto: "user_downlink"),
    3: .standard(proto: "user_online"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.userUplink) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.userDownlink) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.userOnline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userUplink != false {
      try visitor.visitSingularBoolField(value: self.userUplink, fieldNumber: 1)
    }
    if self.userDownlink != false {
      try visitor.visitSingularBoolField(value: self.userDownlink, fieldNumber: 2)
    }
    if self.userOnline != false {
      try visitor.visitSingularBoolField(value: self.userOnline, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_Policy.Stats, rhs: Xray_App_Policy_Policy.Stats) -> Bool {
    if lhs.userUplink != rhs.userUplink {return false}
    if lhs.userDownlink != rhs.userDownlink {return false}
    if lhs.userOnline != rhs.userOnline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Policy_Policy.Buffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xray_App_Policy_Policy.protoMessageName + ".Buffer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.connection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.connection != 0 {
      try visitor.visitSingularInt32Field(value: self.connection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_Policy.Buffer, rhs: Xray_App_Policy_Policy.Buffer) -> Bool {
    if lhs.connection != rhs.connection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Policy_SystemPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_SystemPolicy, rhs: Xray_App_Policy_SystemPolicy) -> Bool {
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Policy_SystemPolicy.Stats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xray_App_Policy_SystemPolicy.protoMessageName + ".Stats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inbound_uplink"),
    2: .standard(proto: "inbound_downlink"),
    3: .standard(proto: "outbound_uplink"),
    4: .standard(proto: "outbound_downlink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.inboundUplink) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.inboundDownlink) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.outboundUplink) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.outboundDownlink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inboundUplink != false {
      try visitor.visitSingularBoolField(value: self.inboundUplink, fieldNumber: 1)
    }
    if self.inboundDownlink != false {
      try visitor.visitSingularBoolField(value: self.inboundDownlink, fieldNumber: 2)
    }
    if self.outboundUplink != false {
      try visitor.visitSingularBoolField(value: self.outboundUplink, fieldNumber: 3)
    }
    if self.outboundDownlink != false {
      try visitor.visitSingularBoolField(value: self.outboundDownlink, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_SystemPolicy.Stats, rhs: Xray_App_Policy_SystemPolicy.Stats) -> Bool {
    if lhs.inboundUplink != rhs.inboundUplink {return false}
    if lhs.inboundDownlink != rhs.inboundDownlink {return false}
    if lhs.outboundUplink != rhs.outboundUplink {return false}
    if lhs.outboundDownlink != rhs.outboundDownlink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xray_App_Policy_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "system"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Xray_App_Policy_Policy>.self, value: &self.level) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._system) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.level.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Xray_App_Policy_Policy>.self, value: self.level, fieldNumber: 1)
    }
    try { if let v = self._system {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xray_App_Policy_Config, rhs: Xray_App_Policy_Config) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs._system != rhs._system {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
